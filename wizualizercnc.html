<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNC Viz 11.5 - Solid Studio (Z-Top Base)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0b0b0d; color: #e0e0e0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1f2937 0%, #000000 120%); }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .panel {
            pointer-events: auto;
            background: rgba(18, 18, 20, 0.96);
            border: 1px solid #333;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            backdrop-filter: blur(12px);
            display: flex; flex-direction: column;
        }

        /* Nowy, jednolity styl przycisk√≥w */
        .btn-toolbar {
            @apply px-3 py-1.5 rounded border text-[11px] font-bold tracking-wide transition uppercase flex items-center gap-2;
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.1);
            color: #bbb;
        }
        .btn-toolbar:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        .btn-toolbar.action-save { @apply hover:border-green-500 hover:text-green-400 hover:shadow-green-900/50; }
        .btn-toolbar.action-txt { @apply hover:border-blue-500 hover:text-blue-400 hover:shadow-blue-900/50; }
        .btn-toolbar.action-cam { @apply w-10 justify-center px-0; }

        /* Details / Accordion */
        details > summary {
            list-style: none; cursor: pointer; padding: 8px;
            background-color: rgba(255, 255, 255, 0.03); border-bottom: 1px solid #333;
            font-size: 11px; font-weight: 700; color: #60a5fa; text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s;
        }
        details > summary:hover { background-color: rgba(255, 255, 255, 0.07); }
        details > summary::after { content: '+'; font-size: 14px; font-weight: bold; }
        details[open] > summary::after { content: '-'; }
        .details-content { padding: 10px; max-height: 350px; overflow-y: auto; }

        /* Editor */
        .editor-wrapper {
            position: relative; display: flex; height: 100%; background-color: #0d0d0d;
            font-family: 'JetBrains Mono', 'Consolas', monospace; font-size: 13px; line-height: 20px; overflow: hidden;
        }
        .line-numbers {
            min-width: 35px; background-color: #151515; color: #555; text-align: right; padding: 10px 6px 10px 0;
            border-right: 1px solid #333; user-select: none; overflow: hidden; white-space: pre-wrap;
        }
        textarea { 
            flex-grow: 1; background-color: transparent; color: #a5f3fc; border: none; outline: none; padding: 10px;
            resize: none; white-space: pre; overflow-wrap: normal; overflow-x: auto; overflow-y: scroll;
        }
        textarea::selection { background-color: #2563eb; color: white; }

        /* Inputs */
        input[type=number], select, input[type=text] {
            background-color: #000 !important; color: #ffffff !important;
            border: 1px solid #444 !important; border-radius: 3px; padding: 2px 6px;
            font-family: monospace; font-weight: 500; width: 100%; font-size: 11px; transition: border-color 0.2s;
        }
        input[type=number]:focus, select:focus { outline: none; border-color: #3b82f6 !important; }
        
        /* Tool Table */
        table { width: 100%; border-collapse: collapse; font-size: 10px; }
        th { text-align: left; color: #9ca3af; font-weight: 700; padding: 4px; border-bottom: 1px solid #444; font-size: 9px; text-transform: uppercase; }
        td { padding: 2px; border-bottom: 1px solid #222; vertical-align: middle; }
        .del-btn { color: #ef4444; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .del-btn:hover { color: #fca5a5; }

        label { color: #9ca3af !important; font-size: 10px !important; font-weight: 700 !important; text-transform: uppercase; letter-spacing: 0.05em; display: block; margin-bottom: 2px; }
        .chk-container { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .chk-box { width: 14px; height: 14px; border: 1px solid #555; border-radius: 3px; background: #1a1a1a; display: flex; align-items: center; justify-content: center; }
        input[type="checkbox"] { display: none; }
        input[type="checkbox"]:checked + .chk-box { background: #2563eb; border-color: #2563eb; }
        input[type="checkbox"]:checked + .chk-box::after { content: '‚úì'; font-size: 10px; color: white; }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0d0d0d; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        input[type=range] { -webkit-appearance: none; background: transparent; height: 20px; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #3b82f6; margin-top: -5px; border: 2px solid #ffffff; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        .heatmap-gradient { width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, #3b82f6, #10b981, #eab308, #ef4444); margin-top: 4px; }
        .gcode-row { display: flex; justify-content: space-between; padding: 2px 0; border-bottom: 1px solid #222; font-family: monospace; font-size: 10px; color: #aaa; }
        .gcode-key { color: #93c5fd; font-weight: bold; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="p-3">
        
        <!-- Top Bar -->
        <div class="panel w-full flex items-center justify-between p-2 mb-3 h-12 flex-row gap-2">
            <div class="flex items-center gap-4 pl-2">
                <div class="font-bold text-lg tracking-widest text-white flex items-center gap-2 select-none">
                    <span class="text-blue-500">CNC</span><span class="text-gray-400">VIZ</span>
                    <span class="bg-blue-900/50 text-blue-200 text-[10px] px-1.5 py-0.5 rounded border border-blue-800">V11.5</span>
                </div>
            </div>

            <div class="flex items-center gap-2 pr-2">
                <label class="btn-toolbar cursor-pointer">
                    <input type="file" id="file-upload" accept=".nc,.gcode,.txt" class="hidden">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    <span>OTW√ìRZ</span>
                </label>
                
                <button id="btn-export-stl" class="btn-toolbar action-save">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                    <span>STL</span>
                </button>
                
                <button id="btn-export-txt" class="btn-toolbar action-txt">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span>TXT</span>
                </button>
                
                <div class="h-4 w-px bg-gray-700 mx-1"></div>
                
                <button id="cam-iso" class="btn-toolbar action-cam" title="Widok ISO">ISO</button>
                <button id="cam-top" class="btn-toolbar action-cam" title="Widok z g√≥ry">TOP</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex flex-col md:flex-row gap-3 h-full overflow-hidden pb-3 relative">
            
            <!-- Left Sidebar -->
            <div class="flex flex-col gap-3 w-full md:w-80 lg:w-96 flex-shrink-0 order-2 md:order-1 max-h-[calc(100vh-90px)] overflow-hidden">
                
                <!-- Accordion Panel -->
                <div class="panel flex-shrink-0 overflow-hidden flex flex-col" style="max-height: 60%;">
                    
                    <!-- Tools Section -->
                    <details open class="border-b border-gray-800">
                        <summary>Mened≈ºer Narzƒôdzi</summary>
                        <div class="details-content bg-black/20">
                            <table class="mb-2">
                                <thead><tr><th width="5%"></th><th width="15%">T#</th><th width="35%">Typ</th><th width="20%">√ò</th><th width="25%">Ostrze</th></tr></thead>
                                <tbody id="tool-table-body"></tbody>
                            </table>
                            <button onclick="addNewTool()" class="w-full bg-gray-800 hover:bg-gray-700 text-[10px] text-blue-400 py-1 rounded border border-gray-700 border-dashed">+ DODAJ NARZƒòDZIE</button>
                        </div>
                    </details>

                    <!-- Stock Section -->
                    <details>
                        <summary>Przygot√≥wka (Stock)</summary>
                        <div class="details-content space-y-3">
                            <div class="grid grid-cols-3 gap-2">
                                <div><label>X (Szer)</label><input type="number" id="stock-w" value="100"></div>
                                <div><label>Y (D≈Çug)</label><input type="number" id="stock-d" value="100"></div>
                                <div><label>Z (Wys)</label><input type="number" id="stock-h" value="20"></div>
                            </div>
                            <div class="flex gap-3 items-center justify-between text-[10px]">
                                <label class="chk-container"><input type="checkbox" id="chk-invert-y"><span class="chk-box"></span><span>Lustro Y</span></label>
                                <label class="chk-container"><input type="checkbox" id="chk-comp"><span class="chk-box"></span><span>Kompensacja</span></label>
                            </div>
                            <button id="btn-update-stock" class="bg-blue-700 hover:bg-blue-600 text-[10px] font-bold text-white rounded py-1.5 w-full shadow">AKTUALIZUJ BRY≈Åƒò</button>
                        </div>
                    </details>

                    <!-- G-Code Info Section -->
                    <details>
                        <summary>Info G-Code (Legenda)</summary>
                        <div class="details-content">
                            <div id="gcode-legend" class="space-y-0">
                                <!-- Dynamic Content -->
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Code Editor -->
                <div class="panel flex-grow flex flex-col overflow-hidden border-t-2 border-blue-600 min-h-0">
                    <div class="p-1.5 bg-[#151515] border-b border-gray-800 flex justify-between items-center flex-shrink-0">
                        <span class="text-[10px] font-bold text-gray-400 uppercase tracking-widest pl-2">Program NC</span>
                        <div class="flex gap-2">
                            <button id="btn-save-local" class="text-xs text-gray-500 hover:text-white" title="Zapisz do pamiƒôci przeglƒÖdarki">üíæ Auto-Save</button>
                            <button id="btn-render" class="bg-green-700 hover:bg-green-600 text-white text-[10px] font-bold py-0.5 px-2 rounded uppercase tracking-wide transition">Przelicz</button>
                        </div>
                    </div>
                    <div class="editor-wrapper flex-grow">
                        <div id="line-numbers" class="line-numbers">1</div>
                        <textarea id="gcode-input" spellcheck="false" placeholder="Wklej G-kod..."></textarea>
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="panel p-3 flex-shrink-0">
                    <div class="flex items-center justify-between mb-2 gap-3">
                        <button id="btn-play" class="w-8 h-8 flex-shrink-0 rounded-full bg-white text-black hover:bg-gray-200 flex items-center justify-center transition shadow-lg">
                            <svg id="icon-play" class="w-4 h-4 ml-0.5" fill="currentColor" viewBox="0 0 20 20"><path d="M4 4l12 6-12 6z"/></svg>
                            <svg id="icon-pause" class="w-4 h-4 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4h3v12H5V4zm7 0h3v12h-3V4z"/></svg>
                        </button>
                        <div class="flex flex-col flex-grow">
                             <div class="flex justify-between text-[10px] font-bold text-gray-400 mb-1 font-mono">
                                <span id="current-line-idx" class="text-blue-400">N: 0</span>
                                <span id="tool-display" class="text-yellow-400">T: -</span>
                                <span id="progress-percent" class="text-green-400">0%</span>
                            </div>
                            <input type="range" id="progress-slider" min="0" max="1000" value="0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <button id="btn-reset" class="p-1.5 text-gray-500 hover:text-white transition" title="Resetuj"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg></button>
                    </div>
                </div>
            </div>

            <!-- Right DRO & Stats -->
            <div class="absolute right-4 top-4 pointer-events-none flex flex-col gap-2 items-end">
                <div class="panel p-4 pointer-events-auto min-w-[200px]">
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2 border-b border-gray-700 pb-1">POZYCJA (DRO)</div>
                    <div class="font-mono text-lg grid grid-cols-[20px_1fr] gap-y-1">
                        <span class="text-red-500 font-bold">X</span><span id="pos-x" class="text-right text-white font-bold tracking-wider">0.00</span>
                        <span class="text-green-500 font-bold">Y</span><span id="pos-y" class="text-right text-white font-bold tracking-wider">0.00</span>
                        <span class="text-blue-500 font-bold">Z</span><span id="pos-z" class="text-right text-white font-bold tracking-wider">0.00</span>
                    </div>
                    <div id="collision-alert" class="hidden mt-2 text-center bg-red-900/90 border border-red-600 text-white text-[10px] font-bold py-2 px-2 rounded animate-pulse shadow-[0_0_15px_rgba(255,0,0,0.5)]">
                        ‚ö†Ô∏è KOLIZJA ‚ö†Ô∏è<br><span id="collision-msg">OPRAWKA</span>
                    </div>
                </div>
                
                <div class="panel p-3 pointer-events-auto min-w-[200px]">
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2">G≈ÅƒòBOKO≈öƒÜ SKRAWANIA</div>
                    <div class="heatmap-gradient"></div>
                    <div class="flex justify-between text-[9px] text-gray-400 mt-1 font-mono">
                        <span>0 (G√ìRA)</span>
                        <span>MAX</span>
                    </div>
                </div>

                <div class="panel p-3 pointer-events-auto text-[10px] text-gray-400 px-4 flex flex-col items-end gap-1">
                   <span class="font-bold border-b border-gray-700 pb-1 mb-1 block w-full text-right">ZAKRESY</span>
                   <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-right">
                       <span>X:</span><span id="range-x" class="text-white font-mono">-</span>
                       <span>Y:</span><span id="range-y" class="text-white font-mono">-</span>
                       <span>Z:</span><span id="range-z" class="text-white font-mono">-</span>
                   </div>
                   <span class="mt-2 pt-2 border-t border-gray-800 w-full text-right text-green-400 font-bold">Czas: <span id="est-time" class="text-white font-mono">00:00:00</span></span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';

        // --- KONFIGURACJA ---
        const CONF = {
            colorStockTop: 0xcccccc, 
            colorStockSide: 0x888888, 
            millRes: 256, // Rozdzielczo≈õƒá siatki
            rapidSpeed: 3000, 
            defaultFeed: 500,
            toolChangePos: { x:0, y:0, z:50 } // Makro wymiany narzƒôdzia
        };

        const STORAGE_KEY = 'cnc_viz_data_v11';

        // --- DATA: Tool Library (Mutable) ---
        let toolsDB = [
            { id: 1, type: 'FLAT', dia: 40, len: 50 }, // G≈Çowica
            { id: 2, type: 'FLAT', dia: 10, len: 30 }, // P≈Çaski
            { id: 3, type: 'BALL', dia: 6, len: 20 },  // Kulowy
            { id: 4, type: 'DRILL', dia: 5, len: 40 }, // Wiert≈Ço
            { id: 5, type: 'TAP', dia: 6, len: 35 }    // Gwintownik
        ];

        // --- DATA: G-Code Descriptions ---
        const G_DESC = {
            'G0': 'Ruch Szybki', 'G1': 'Ruch Roboczy', 'G2': '≈Åuk CW', 'G3': '≈Åuk CCW',
            'G17': 'P≈Çaszczyzna XY', 'G18': 'P≈Çaszczyzna XZ', 'G19': 'P≈Çaszczyzna YZ',
            'G40': 'Kompensacja: OFF', 'G41': 'Kompensacja: Lewa', 'G42': 'Kompensacja: Prawa',
            'G43': 'Kompensacja D≈Çugo≈õci', 'G49': 'Anuluj Komp. D≈Ç.',
            'G54': 'Uk≈Çad Wsp√≥≈Çrzƒôdnych 1', 'G80': 'Anuluj Cykl',
            'G81': 'Wiercenie', 'G83': 'Wiercenie G≈Çƒôbokie (Peck)', 'G84': 'Gwintowanie',
            'G90': 'Wsp√≥≈Çrzƒôdne Absolutne', 'G91': 'Wsp√≥≈Çrzƒôdne Przyrostowe',
            'M3': 'Wrzeciono CW', 'M4': 'Wrzeciono CCW', 'M5': 'Stop Wrzeciona',
            'M6': 'Zmiana Narzƒôdzia (AUTO)', 'M8': 'Ch≈Çodziwo ON', 'M9': 'Ch≈Çodziwo OFF', 'M30': 'Koniec Programu',
            'T': 'Wyb√≥r Narzƒôdzia', 'F': 'Posuw', 'S': 'Obroty'
        };

        const state = {
            isPlaying: false, speed: 1, progress: 0, currentSegmentIdx: 0, segments: [],
            bounds: { min: new THREE.Vector3(), max: new THREE.Vector3() },
            activeToolId: 1, stockMesh: null, 
            gridMap: null,
            stockDims: { w: 100, d: 100, h: 20, stepX: 1, stepZ: 1, segs: 256 },
            invertY: false, useComp: false, totalTimeMin: 0, simulatedHeadIdx: 0
        };

        let scene, camera, renderer, controls;
        let toolMesh, toolFlutes, toolShank, highlightMesh, highlightSphere;
        let pathGroup = new THREE.Group();
        let helpersGroup = new THREE.Group();
        let raycaster, mouse, chipSystem;
        
        const el = (id) => document.getElementById(id);
        const els = {
            input: el('gcode-input'), lineNums: el('line-numbers'),
            btnRender: el('btn-render'), btnPlay: el('btn-play'), btnReset: el('btn-reset'), 
            btnExportSTL: el('btn-export-stl'), btnExportTXT: el('btn-export-txt'),
            slider: el('progress-slider'), btnUpdateStock: el('btn-update-stock'),
            chkInvertY: el('chk-invert-y'), chkComp: el('chk-comp'),
            stockW: el('stock-w'), stockD: el('stock-d'), stockH: el('stock-h'), 
            toolTableBody: el('tool-table-body'), gcodeLegend: el('gcode-legend'),
            posX: el('pos-x'), posY: el('pos-y'), posZ: el('pos-z'), 
            collisionAlert: el('collision-alert'), collisionMsg: el('collision-msg'),
            rangeX: el('range-x'), rangeY: el('range-y'), rangeZ: el('range-z'),
            lineIdx: el('current-line-idx'), percent: el('progress-percent'), estTime: el('est-time'), toolDisplay: el('tool-display'),
            iconPlay: el('icon-play'), iconPause: el('icon-pause')
        };

        // --- Persistence ---
        function loadData() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (data.tools) toolsDB = data.tools;
                    if (data.code) els.input.value = data.code;
                    if (data.dims) {
                        els.stockW.value = data.dims.w;
                        els.stockD.value = data.dims.d;
                        els.stockH.value = data.dims.h;
                    }
                }
            } catch (e) { console.warn("Failed to load local data", e); }
        }

        function saveData() {
            const data = {
                tools: toolsDB,
                code: els.input.value,
                dims: { w: els.stockW.value, d: els.stockD.value, h: els.stockH.value }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        // --- UI Functions ---
        function renderToolTable() {
            const tbody = els.toolTableBody; tbody.innerHTML = '';
            toolsDB.forEach((t, idx) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="text-center"><span class="del-btn" onclick="removeTool(${idx})">√ó</span></td>
                    <td><input type="number" value="${t.id}" onchange="editTool(${idx}, 'id', this.value)" style="width:40px; text-align:center;"></td>
                    <td><select onchange="editTool(${idx}, 'type', this.value)" class="bg-transparent border-none h-5 text-[10px]">
                        <option value="FLAT" ${t.type==='FLAT'?'selected':''}>Frez P≈Çaski</option>
                        <option value="BALL" ${t.type==='BALL'?'selected':''}>Frez Kulowy</option>
                        <option value="DRILL" ${t.type==='DRILL'?'selected':''}>Wiert≈Ço</option>
                        <option value="TAP" ${t.type==='TAP'?'selected':''}>Gwintownik</option>
                    </select></td>
                    <td><input type="number" value="${t.dia}" onchange="editTool(${idx}, 'dia', this.value)" class="h-5 text-[10px]"></td>
                    <td><input type="number" value="${t.len}" onchange="editTool(${idx}, 'len', this.value)" class="h-5 text-[10px]"></td>
                `;
                tbody.appendChild(tr);
            });
            saveData();
        }
        window.editTool = (arrIdx, key, val) => {
            const t = toolsDB[arrIdx];
            if(key==='type') t.type=val; else t[key]=parseFloat(val);
            if(t.id === state.activeToolId) updateToolMesh(t.id);
            saveData();
        };
        window.removeTool = (arrIdx) => {
            toolsDB.splice(arrIdx, 1); renderToolTable(); saveData();
        };
        window.addNewTool = () => {
            const newId = toolsDB.length > 0 ? Math.max(...toolsDB.map(t=>t.id)) + 1 : 1;
            toolsDB.push({ id: newId, type: 'FLAT', dia: 10, len: 30 });
            renderToolTable();
        };
        
        function updateBounds(v) { 
            state.bounds.min.min(v); 
            state.bounds.max.max(v); 
        }

        function updateLineNumbers() {
            const lines = els.input.value.split('\n').length;
            els.lineNums.innerHTML = Array(lines).fill(0).map((_, i) => i + 1).join('<br>');
        }

        // --- Chip System ---
        class ChipSystem {
            constructor(scene) {
                this.max = 3000; this.idx = 0;
                this.geo = new THREE.BufferGeometry();
                this.pos = new Float32Array(this.max*3); this.vel = new Float32Array(this.max*3); this.life = new Float32Array(this.max);
                this.geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.mesh = new THREE.Points(this.geo, new THREE.PointsMaterial({color: 0xffd700, size: 0.6, transparent: true, opacity:0.8}));
                this.mesh.frustumCulled = false; scene.add(this.mesh);
            }
            emit(p, vol) {
                const cnt = Math.min(Math.floor(vol*5), 40);
                for(let i=0; i<cnt; i++) {
                    const k = this.idx;
                    this.pos[k*3] = p.x+(Math.random()-0.5)*2; this.pos[k*3+1] = p.y+Math.random(); this.pos[k*3+2] = p.z+(Math.random()-0.5)*2;
                    this.vel[k*3] = (Math.random()-0.5)*3; this.vel[k*3+1] = Math.random()*3+2; this.vel[k*3+2] = (Math.random()-0.5)*3;
                    this.life[k] = 1.0;
                    this.idx = (this.idx+1) % this.max;
                }
            }
            update() {
                for(let i=0; i<this.max; i++) {
                    if(this.life[i]>0) {
                        this.vel[i*3+1] -= 0.15;
                        this.pos[i*3] += this.vel[i*3]; this.pos[i*3+1] += this.vel[i*3+1]; this.pos[i*3+2] += this.vel[i*3+2];
                        if(this.pos[i*3+1]<0) { this.pos[i*3+1]=0; this.vel[i*3+1]*=-0.5; this.vel[i*3]*=0.8; this.vel[i*3+2]*=0.8; }
                        this.life[i] -= 0.03;
                    } else { this.pos[i*3+1] = -999; }
                }
                this.geo.attributes.position.needsUpdate = true;
            }
        }

        function init() {
            loadData();

            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x1a1a20, 0.001);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(120, 150, 200);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            el('canvas-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor=0.05;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(50, 200, 100); dl.castShadow=true; 
            dl.shadow.mapSize.width=2048; dl.shadow.mapSize.height=2048; scene.add(dl);
            
            scene.add(pathGroup); scene.add(helpersGroup);
            
            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 3.0; 
            mouse = new THREE.Vector2();

            chipSystem = new ChipSystem(scene);
            
            const hg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            highlightMesh = new THREE.Line(hg, new THREE.LineBasicMaterial({color:0xff00ff, linewidth:5, depthTest:false}));
            highlightMesh.renderOrder=999; highlightMesh.visible=false; scene.add(highlightMesh);
            highlightSphere = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color:0xff00ff, depthTest:false}));
            highlightSphere.renderOrder=999; highlightSphere.visible=false; scene.add(highlightSphere);

            renderToolTable();
            updateToolMesh(1); updateEnvironment();
            
            if (!els.input.value) els.input.value = sampleMill;
            updateLineNumbers(); 
            processCode();
            
            window.addEventListener('resize', onResize);
            el('canvas-container').addEventListener('mousedown', on3DClick);
            els.input.addEventListener('click', onEditorClick);
            els.input.addEventListener('keyup', onEditorClick);
            els.input.addEventListener('input', () => { updateLineNumbers(); saveData(); });
            els.input.addEventListener('scroll', () => { els.lineNums.scrollTop = els.input.scrollTop; });
            els.slider.addEventListener('input', onSliderScrub);
            animate();
        }

        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function updateToolMesh(id) {
            state.activeToolId = id;
            const t = toolsDB.find(x => x.id == id) || toolsDB[0];
            if(!t) return;
            
            const r = t.dia / 2;
            const fluteLen = t.len;
            
            els.toolDisplay.innerText = `T${id}: ${t.type} D${t.dia}`;
            
            if(toolMesh) scene.remove(toolMesh);
            toolMesh = new THREE.Group();
            
            let tipGeo, flutes, shank;
            
            if (t.type === 'BALL') {
                tipGeo = new THREE.SphereGeometry(r, 32, 16); tipGeo.translate(0, r, 0);
                const cylGeo = new THREE.CylinderGeometry(r, r, fluteLen - r, 32);
                cylGeo.translate(0, r + (fluteLen-r)/2, 0);
                flutes = new THREE.Group();
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
                flutes.add(new THREE.Mesh(cylGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
            } else if (t.type === 'DRILL' || t.type === 'TAP') {
                const tipH = r / Math.tan(59 * Math.PI/180);
                tipGeo = new THREE.ConeGeometry(r, tipH, 32);
                tipGeo.rotateX(Math.PI); tipGeo.translate(0, tipH/2, 0);
                const bodyLen = fluteLen - tipH;
                const bodyGeo = new THREE.CylinderGeometry(r, r, bodyLen, 32);
                bodyGeo.translate(0, tipH + bodyLen/2, 0);
                flutes = new THREE.Group();
                const color = t.type === 'TAP' ? 0x88ccff : 0xFFD700; // Blueish for Tap
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: color })));
                flutes.add(new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color: color })));
            } else {
                tipGeo = new THREE.CylinderGeometry(r, r, fluteLen, 32);
                tipGeo.translate(0, fluteLen/2, 0);
                flutes = new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 }));
            }
            
            flutes.castShadow = true; toolFlutes = flutes; 
            
            const shankLen = 40;
            const shankGeo = new THREE.CylinderGeometry(r, r, shankLen, 32);
            shankGeo.translate(0, fluteLen + shankLen/2, 0);
            shank = new THREE.Mesh(shankGeo, new THREE.MeshStandardMaterial({ color: 0xAAAAAA }));
            toolShank = shank;

            toolMesh.add(flutes); toolMesh.add(shank); scene.add(toolMesh);
        }

        // --- ENVIRONMENT: GRID AND TABLE ---
        function updateEnvironment() {
            helpersGroup.clear();
            helpersGroup.add(new THREE.GridHelper(300, 30, 0x555555, 0x222222));
            helpersGroup.add(new THREE.AxesHelper(30));
            const lbl = (t,c,p) => {
                const cv=document.createElement('canvas'); cv.width=64; cv.height=64;
                const x=cv.getContext('2d'); x.fillStyle=c; x.font="bold 48px Arial"; x.fillText(t,32,48);
                const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv), transparent:true, depthTest:false}));
                s.position.copy(p); s.scale.set(8,8,1); helpersGroup.add(s);
            };
            lbl("X", "#f44", new THREE.Vector3(35,0,0)); lbl("Z", "#44f", new THREE.Vector3(0,35,0)); lbl("Y", "#4f4", new THREE.Vector3(0,0,-35));
            
            // FIX: St√≥≈Ç/Siatka pomocnicza powinna byƒá na spodzie materia≈Çu, je≈õli Z=0 to g√≥ra.
            // Stock Top = 0. Stock Height = h. Stock Bottom = -h.
            const h = parseFloat(els.stockH.value)||20;
            
            // Przesuwamy GridHelper i Table na poziom -h (sp√≥d materia≈Çu)
            const grid = new THREE.GridHelper(300, 30, 0x444444, 0x222222);
            grid.position.y = -h;
            helpersGroup.add(grid);

            const table = new THREE.Mesh(new THREE.BoxGeometry(300, 2, 300), new THREE.MeshStandardMaterial({color:0x111111}));
            table.position.y = -h - 1; // 1 to po≈Çowa grubo≈õci sto≈Çu (2)
            table.receiveShadow = true; 
            helpersGroup.add(table);

            createStockMesh();
        }

        // --- STOCK MESH: Z=0 is TOP ---
        function createStockMesh() {
            if (state.stockMesh) { scene.remove(state.stockMesh); if(state.stockMesh.geometry) state.stockMesh.geometry.dispose(); }
            
            const w = parseFloat(els.stockW.value)||100; 
            const d = parseFloat(els.stockD.value)||100; 
            const h = parseFloat(els.stockH.value)||20;
            
            const segs = CONF.millRes;
            const geo = new THREE.BoxGeometry(w, h, d, segs, 1, segs);
            
            const count = geo.attributes.position.count;
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*3), 3));
            const col = geo.attributes.color;
            const pos = geo.attributes.position;
            
            const topColor = new THREE.Color(CONF.colorStockTop);
            const sideColor = new THREE.Color(CONF.colorStockSide);
            
            state.gridMap = new Array((segs + 1) * (segs + 1)).fill(null).map(() => []);
            const stepX = w / segs;
            const stepZ = d / segs;
            
            // Zapisujemy parametry do stanu, aby funkcja kolizji mog≈Ça z nich korzystaƒá
            state.stockDims = { w, d, h, stepX, stepZ, segs };

            const epsilon = 0.01;

            for(let i=0; i<count; i++) {
                const y = pos.getY(i);
                // BoxGeometry jest wycentrowane w 0,0,0. Wysoko≈õƒá h.
                // Zatem lokalne Y idzie od -h/2 do +h/2.
                // G√≥ra to h/2.
                if (y > (h/2 - epsilon)) {
                    col.setXYZ(i, topColor.r, topColor.g, topColor.b);
                    
                    const x = pos.getX(i) + w/2;
                    const z = pos.getZ(i) + d/2;
                    const ix = Math.round(x / stepX);
                    const iz = Math.round(z / stepZ);
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (state.gridMap[gridIdx]) state.gridMap[gridIdx].push(i);
                } else {
                    col.setXYZ(i, sideColor.r, sideColor.g, sideColor.b);
                }
            }

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.5, metalness: 0.3, flatShading: false });
            const mesh = new THREE.Mesh(geo, mat);
            
            // FIX: POZYCJONOWANIE
            // Wcze≈õniej: mesh.position.set(w/2, h/2, -d/2); -> G√≥ra by≈Ça na Y=h.
            // Teraz: Chcemy by G√≥ra (lokalne h/2) by≈Ça na ≈öwiecie Y=0.
            // Zatem Mesh Y = -h/2.
            mesh.position.set(w/2, -h/2, -d/2);
            
            mesh.castShadow = true; mesh.receiveShadow = true;
            state.stockMesh = mesh;
            scene.add(mesh);
            
            state.simulatedHeadIdx = 0;
            saveData();
        }

        function mapCoords(c) { return new THREE.Vector3(c.x, c.z, c.y * (state.invertY ? 1 : -1)); }
        
        // --- NOWA FUNKCJA: Sprawdzanie wysoko≈õci materia≈Çu w danym punkcie ---
        function getMaterialHeightAt(wx, wz) {
            if (!state.stockMesh || !state.gridMap) return -999; // Brak materia≈Çu
            
            const { w, d, h, stepX, stepZ, segs } = state.stockDims;

            // Szybki check bounding box
            if (wx < 0 || wx > w || wz < -d || wz > 0) return -999; // Poza obrysem materia≈Çu jest bezpiecznie (pusto)

            const ix = Math.round(wx / stepX);
            const iz = Math.round((wz + d) / stepZ);

            if (ix < 0 || ix > segs || iz < 0 || iz > segs) return -999;

            const gridIdx = (segs - iz) * (segs + 1) + ix;
            if (gridIdx < 0 || gridIdx >= state.gridMap.length) return -999;

            const vertices = state.gridMap[gridIdx];
            if (!vertices || vertices.length === 0) return -999;

            // Pobieramy wysoko≈õƒá pierwszego wierzcho≈Çka w tym punkcie
            const posAttr = state.stockMesh.geometry.attributes.position;
            const localY = posAttr.getY(vertices[0]);
            
            // World Y = Local Y - h/2 (bo mesh jest przesuniƒôty w d√≥≈Ç o h/2)
            return localY - (h/2);
        }

        function processCode() {
            const lines = els.input.value.split('\n');
            state.segments = []; pathGroup.clear(); highlightMesh.visible=false; highlightSphere.visible=false;
            // Startowa pozycja Z=50 (bezpieczna nad materia≈Çem)
            let curPos = { x:0, y:0, z:50 }; 
            let curMode = 'G0'; let curFeed = CONF.defaultFeed; let curComp = 'G40';
            let curToolId = 1; let totalTimeMin = 0;
            state.bounds.min.set(Infinity, Infinity, Infinity); state.bounds.max.set(-Infinity, -Infinity, -Infinity);
            const usedCodes = new Set();

            lines.forEach((line, idx) => {
                let clean = line.replace(/\(.*\)/g, '').split(';')[0].trim().toUpperCase();
                if(!clean) return;
                const tokens = clean.match(/[GM]\d+/g);
                if(tokens) tokens.forEach(t => usedCodes.add(t));
                if(clean.includes('T')) usedCodes.add('T'); if(clean.includes('F')) usedCodes.add('F'); if(clean.includes('S')) usedCodes.add('S');

                // --- TOOL CHANGE MACRO LOGIC (M6) ---
                if(clean.includes('M6')) {
                    // 1. Unie≈õ na bezpieczne Z
                    const pSafeZ = { ...curPos, z: CONF.toolChangePos.z };
                    if(curPos.z < pSafeZ.z) {
                        const pStart = mapCoords(curPos);
                        const pEnd = mapCoords(pSafeZ);
                        state.segments.push({start:pStart, end:pEnd, type:'G0', lineIdx:idx, toolId:curToolId});
                        curPos = pSafeZ;
                    }
                    
                    // 2. Jed≈∫ do pozycji wymiany X/Y
                    const pChange = { x: CONF.toolChangePos.x, y: CONF.toolChangePos.y, z: CONF.toolChangePos.z };
                    const pCStart = mapCoords(curPos);
                    const pCEnd = mapCoords(pChange);
                    state.segments.push({start:pCStart, end:pCEnd, type:'G0', lineIdx:idx, toolId:curToolId});
                    curPos = pChange;
                    
                    // Teraz faktyczna zmiana ID narzƒôdzia nastƒÖpi poni≈ºej
                }

                const tMatch = clean.match(/T(\d+)/);
                if(tMatch) {
                    let tid = parseInt(tMatch[1]);
                    if(tid > 100) tid = Math.floor(tid/100); 
                    if(toolsDB.find(t=>t.id==tid)) curToolId = tid;
                }
                
                if(clean.includes('G40')) curComp='G40'; if(clean.includes('G41')) curComp='G41'; if(clean.includes('G42')) curComp='G42';
                
                let target = { ...curPos }; let hasMove = false;
                const parts = clean.match(/([GXYZFIJRZRKQ])([0-9.-]+)/g);
                let drillR=2, drillQ=0, i=0, j=0;

                if(parts) {
                    parts.forEach(p => {
                        const c = p[0], v = parseFloat(p.slice(1));
                        if(c==='G') { if(v===0) curMode='G0'; else if(v===1) curMode='G1'; else if(v===2) curMode='G2'; else if(v===3) curMode='G3'; }
                        if(c==='X') { target.x=v; hasMove=true; } if(c==='Y') { target.y=v; hasMove=true; } 
                        // Z mapuje siƒô na Y w Three.js, a Y na Z. 
                        if(c==='Z') { target.z=v; hasMove=true; }
                        if(c==='F') curFeed=v;
                        if(c==='R') drillR=v; if(c==='K' || c==='Q') drillQ=v; if(c==='I') i=v; if(c==='J') j=v;
                    });
                }

                if (clean.includes('G81') || clean.includes('G83') || clean.includes('G84')) {
                    const pStart = mapCoords(curPos);
                    const pR = mapCoords({x:target.x, y:target.y, z:drillR});
                    const pZ = mapCoords({x:target.x, y:target.y, z:target.z}); 
                    state.segments.push({start:pStart, end:pR, type:'G0', lineIdx:idx, toolId:curToolId});
                    if(clean.includes('G83') && drillQ > 0) {
                        let d = drillR;
                        while(d > target.z) {
                            let n = Math.max(target.z, d - drillQ);
                            let pIn = mapCoords({x:target.x, y:target.y, z:n});
                            let pOut = mapCoords({x:target.x, y:target.y, z:d+0.5});
                            state.segments.push({start:mapCoords({x:target.x, y:target.y, z:d}), end:pIn, type:'G1', lineIdx:idx, feed:curFeed, toolId:curToolId});
                            state.segments.push({start:pIn, end:pOut, type:'G0', lineIdx:idx, toolId:curToolId});
                            d = n;
                        }
                        state.segments.push({start:mapCoords({x:target.x, y:target.y, z:target.z}), end:pR, type:'G0', lineIdx:idx, toolId:curToolId});
                    } else {
                        state.segments.push({start:pR, end:pZ, type:'G1', lineIdx:idx, feed:curFeed, toolId:curToolId});
                        state.segments.push({start:pZ, end:pR, type:'G0', lineIdx:idx, toolId:curToolId});
                    }
                    curPos = {x:target.x, y:target.y, z:drillR}; 
                    return;
                }

                if (hasMove && (curMode==='G2' || curMode==='G3')) {
                    const p1 = mapCoords(curPos); const p2 = mapCoords(target);
                    const yFact = state.invertY ? 1 : -1;
                    const segs = arcToSegments(p1, p2.x, p2.z, i, j*yFact, curMode==='G2', idx, curToolId, curFeed);
                    segs.forEach(s => state.segments.push(s));
                    curPos = target; return;
                }

                if(hasMove) {
                    const p1 = mapCoords(curPos); const p2 = mapCoords(target);
                    let p1f = p1.clone(), p2f = p2.clone();
                    if(state.useComp && curComp!=='G40' && curMode==='G1') {
                        const t = toolsDB.find(x=>x.id==curToolId) || toolsDB[0];
                        const off = getOffset(p1, p2, curComp, t.dia);
                        p1f.x+=off.x; p1f.z+=off.z; p2f.x+=off.x; p2f.z+=off.z;
                    }
                    updateBounds(p1f); updateBounds(p2f);
                    const dist = p1f.distanceTo(p2f);
                    const speed = curMode==='G0' ? CONF.rapidSpeed : curFeed;
                    totalTimeMin += dist/speed;
                    state.segments.push({start:p1f, end:p2f, type:curMode, lineIdx:idx, feed:curFeed, toolId:curToolId});
                    
                    const color = curMode==='G0' ? 0xff3333 : 0x00ff00;
                    const mat = curMode==='G0' ? new THREE.LineDashedMaterial({color, dashSize:2, gapSize:2, opacity:0.5, transparent:true}) : new THREE.LineBasicMaterial({color});
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1f, p2f]), mat);
                    if(curMode==='G0') line.computeLineDistances();
                    pathGroup.add(line);
                    curPos = target;
                }
            });

            renderLegend(usedCodes);
            const totSec = totalTimeMin * 60;
            els.estTime.innerText = new Date(totSec * 1000).toISOString().substr(11, 8);
            els.rangeX.innerText = `${state.bounds.min.x.toFixed(0)}/${state.bounds.max.x.toFixed(0)}`;
            els.rangeY.innerText = `${state.bounds.min.z.toFixed(0)}/${state.bounds.max.z.toFixed(0)}`;
            els.rangeZ.innerText = `${(-state.bounds.max.y).toFixed(0)}/${(-state.bounds.min.y).toFixed(0)}`;
            resetSim();
            saveData();
        }

        // --- FIXED ARC LOGIC: Adaptive Resolution ---
        function arcToSegments(p1, x2, z2, i, j, isCw, idx, tid, feed) {
            // Center calculation
            const cx = p1.x + i;
            const cz = p1.z + j;
            const r = Math.sqrt(i*i + j*j);
            
            // Calculate start and end angles
            const a1 = Math.atan2(p1.z - cz, p1.x - cx);
            let a2 = Math.atan2(z2 - cz, x2 - cx);
            
            // Handle Wrap-around for CW/CCW logic
            // G2 (CW): Angle decreases. If a2 > a1, we must have crossed -PI/PI boundary.
            if(isCw && a2 > a1) {
                a2 -= Math.PI * 2;
            } 
            // G3 (CCW): Angle increases. If a2 < a1, we crossed boundary.
            else if(!isCw && a2 < a1) {
                a2 += Math.PI * 2;
            }

            // Calculate arc length to determine resolution
            const deltaAngle = Math.abs(a2 - a1);
            const arcLen = r * deltaAngle;
            
            // Adaptive resolution: more segments for longer arcs
            // Minimum 8 segments, max approx 1 segment per 1 unit length (or finer)
            let res = Math.max(12, Math.ceil(arcLen * 2)); 
            // Cap resolution to avoid performance hit on huge circles
            if (res > 128) res = 128;

            const segs = []; 
            const step = (a2 - a1) / res;
            
            let prev = p1.clone();
            
            for(let k=1; k<=res; k++) {
                const th = a1 + step * k;
                const p = new THREE.Vector3(
                    cx + r * Math.cos(th), 
                    p1.y, // Maintain constant Z (in CNC terms) / Y (in Three terms)
                    cz + r * Math.sin(th)
                );
                segs.push({start:prev, end:p, type:'G1', lineIdx:idx, feed, toolId:tid});
                prev = p;
            }
            return segs;
        }

        function renderLegend(codes) {
            els.gcodeLegend.innerHTML = '';
            const sorted = Array.from(codes).sort();
            sorted.forEach(c => {
                const div = document.createElement('div');
                div.className = 'gcode-row';
                div.innerHTML = `<span class="gcode-key">${c}</span> <span>${G_DESC[c] || 'User/Macro'}</span>`;
                els.gcodeLegend.appendChild(div);
            });
        }

        function animate() {
            requestAnimationFrame(animate); controls.update(); chipSystem.update();
            if(state.isPlaying && state.segments.length > 0) {
                const seg = state.segments[state.currentSegmentIdx];
                const dist = seg.start.distanceTo(seg.end);
                let step = (seg.type==='G0' ? 8 : 1) * state.speed; if(dist<0.001) step=1;
                state.progress += step / (dist||1);
                
                if(seg.toolId !== state.activeToolId) updateToolMesh(seg.toolId);

                // --- G0 COLLISION CHECK (FIXED) ---
                // Z=0 to g√≥ra materia≈Çu.
                const curPos = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress);
                
                if (seg.type === 'G0') {
                    // Pobierz aktualnƒÖ wysoko≈õƒá materia≈Çu w tym punkcie
                    // Je≈õli wiert≈Ço jest w otworze, matH bƒôdzie np. -10.
                    const matH = getMaterialHeightAt(curPos.x, curPos.z);
                    
                    // Sprawdzamy kolizjƒô tylko je≈õli narzƒôdzie jest ni≈ºej ni≈º materia≈Ç (+ tolerancja 0.5mm)
                    // Je≈õli matH wynosi -999 (brak materia≈Çu), warunek curPos.y < -999 bƒôdzie fa≈Çszywy (bezpiecznie)
                    if (curPos.y < (matH - 0.5)) {
                        state.isPlaying = false;
                        els.collisionMsg.innerText = "G0 (RAPID) W MATERIALE!";
                        els.collisionAlert.classList.remove('hidden');
                        updatePlayUI();
                        return;
                    }
                }

                if(state.progress >= 1) {
                    if(seg.type === 'G1') { deformStockSegment(seg.start, seg.end, seg.toolId); chipSystem.emit(seg.end, 1.0); }
                    state.simulatedHeadIdx = state.currentSegmentIdx + 1;
                    state.progress = 0; state.currentSegmentIdx++;
                    if(state.currentSegmentIdx >= state.segments.length) {
                        state.isPlaying = false; state.currentSegmentIdx = state.segments.length-1; state.progress=1; updatePlayUI();
                    }
                }
                const curSeg = state.segments[state.currentSegmentIdx];
                const pos = new THREE.Vector3().lerpVectors(curSeg.start, curSeg.end, state.progress);
                toolMesh.position.copy(pos);
                if(curSeg.type==='G1') {
                    const prev = new THREE.Vector3().lerpVectors(curSeg.start, curSeg.end, Math.max(0, state.progress - step/(dist||1)));
                    deformStockSegment(prev, pos, curSeg.toolId); chipSystem.emit(pos, 0.2);
                }
                updateDRO(pos); highlightSelection(curSeg);
                const total = state.segments.length; let ratio = (state.currentSegmentIdx + state.progress) / total;
                if(state.currentSegmentIdx >= total-1 && state.progress >= 1) ratio = 1.0;
                els.percent.innerText = `${Math.floor(ratio*100)}%`;
                if(state.currentSegmentIdx % 10 === 0) els.lineIdx.innerText = `N: ${curSeg.lineIdx + 1}`;
                els.slider.value = ratio * 1000;
            }
            renderer.render(scene, camera);
        }

        function updateDRO(pos) {
            const inv = state.invertY ? 1 : -1;
            els.posX.innerText = pos.x.toFixed(2); els.posY.innerText = (pos.z/inv).toFixed(2); els.posZ.innerText = pos.y.toFixed(2);
            const t = toolsDB.find(x=>x.id==state.activeToolId) || toolsDB[0];
            // Z=0 to g√≥ra. G≈Çƒôboko≈õƒá to po prostu -pos.y (o ile y < 0)
            const depth = -pos.y;
            // Kolizja oprawki
            // Je≈õli g≈Çƒôboko≈õƒá > d≈Çugo≈õƒá narzƒôdzia
            if (depth > t.len) { 
                toolShank.material.color.setHex(0xff0000); 
                els.collisionMsg.innerText = "OPRAWKA";
                els.collisionAlert.classList.remove('hidden'); 
            } 
            else { 
                toolShank.material.color.setHex(0xaaaaaa); 
                if (els.collisionMsg.innerText === "OPRAWKA") els.collisionAlert.classList.add('hidden'); 
            }
        }

        function resetSim() {
            state.isPlaying = false; state.currentSegmentIdx = 0; state.progress = 0; els.slider.value = 0; els.percent.innerText = "0%"; updatePlayUI();
            if(state.segments.length>0) { toolMesh.position.copy(state.segments[0].start); if(state.segments[0].toolId !== state.activeToolId) updateToolMesh(state.segments[0].toolId); }
            restoreStock(); highlightMesh.visible=false; highlightSphere.visible=false; els.collisionAlert.classList.add('hidden');
        }
        function restoreStock() {
            if(!state.stockMesh) return;
            const geo = state.stockMesh.geometry;
            const pos = geo.attributes.position; 
            const col = geo.attributes.color; 
            
            const w = parseFloat(els.stockW.value);
            const h = parseFloat(els.stockH.value);

            const topColor = new THREE.Color(CONF.colorStockTop);
            const map = state.gridMap;
            if(!map) return;

            map.forEach(indices => {
                indices.forEach(idx => {
                    // Resetujemy do h/2 (lokalny top w boxie), kt√≥ry po przesuniƒôciu mesha jest na World Y=0
                    pos.setY(idx, h/2); 
                    col.setXYZ(idx, topColor.r, topColor.g, topColor.b);
                });
            });

            pos.needsUpdate=true; col.needsUpdate=true; geo.computeVertexNormals();
            state.simulatedHeadIdx = 0;
        }
        function simulateToState(idx) {
            if(idx < state.simulatedHeadIdx) restoreStock();
            for(let i=state.simulatedHeadIdx; i<idx; i++) { const s = state.segments[i]; if(s.type==='G1') deformStockSegment(s.start, s.end, s.toolId); }
            state.simulatedHeadIdx = idx;
        }
        
        function deformStockSegment(p1, p2, toolId) {
            if (!state.stockMesh) return;
            const t = toolsDB.find(x=>x.id==toolId) || toolsDB[0];
            const r = t.dia / 2; const rSq = r*r;
            
            const geo = state.stockMesh.geometry; 
            const posAttr = geo.attributes.position; 
            const colAttr = geo.attributes.color;
            
            const w = parseFloat(els.stockW.value); 
            const d = parseFloat(els.stockD.value); 
            const stockH = parseFloat(els.stockH.value);
            
            // Mesh World Pos Y = -stockH/2.
            // Vertex Local Y = World Y - Mesh Pos Y
            // Vertex Local Y = World Y + stockH/2

            const segs = CONF.millRes;
            const stepX = w / segs; 
            const stepZ = d / segs;
            
            const worldToGridX = (wx) => Math.round(wx / stepX);
            const worldToGridZ = (wz) => Math.round((wz + d) / stepZ); 

            const p1x = p1.x; const p1z = p1.z;
            const p2x = p2.x; const p2z = p2.z;

            const minX = Math.min(p1x, p2x) - r - stepX; 
            const maxX = Math.max(p1x, p2x) + r + stepX;
            const minZ = Math.min(p1z, p2z) - r - stepZ;
            const maxZ = Math.max(p1z, p2z) + r + stepZ;

            const iMinX = Math.max(0, Math.floor(minX / stepX));
            const iMaxX = Math.min(segs, Math.ceil(maxX / stepX));
            const iMinZ = Math.max(0, Math.floor((minZ + d) / stepZ));
            const iMaxZ = Math.min(segs, Math.ceil((maxZ + d) / stepZ));

            const tipH = Math.min(p1.y, p2.y); // To jest World Y (np. -5)
            
            const l2 = (p1x-p2x)**2 + (p1z-p2z)**2;
            const isBall = t.type==='BALL'; const isDrill = t.type==='DRILL' || t.type==='TAP';

            for(let iz=iMinZ; iz<=iMaxZ; iz++) {
                for(let ix=iMinX; ix<=iMaxX; ix++) {
                    
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (gridIdx < 0 || gridIdx >= state.gridMap.length) continue;
                    
                    const vertices = state.gridMap[gridIdx];
                    if (!vertices || vertices.length === 0) continue;

                    const wx = ix * stepX;
                    const wz = (iz * stepZ) - d;

                    let distSq;
                    if(l2===0) distSq = (wx-p1x)**2 + (wz-p1z)**2;
                    else {
                        let t = ((wx-p1x)*(p2x-p1x) + (wz-p1z)*(p2z-p1z)) / l2; t = Math.max(0, Math.min(1, t));
                        distSq = (wx-(p1x+t*(p2x-p1x)))**2 + (wz-(p1z+t*(p2z-p1z)))**2;
                    }

                    if(distSq < rSq) {
                        const firstV = vertices[0];
                        // Obecny World Y wierzcho≈Çka
                        // LocalY = posAttr.getY(firstV).
                        // WorldY = LocalY + mesh.position.y (czyli -stockH/2)
                        const currentWorldY = posAttr.getY(firstV) - stockH/2;

                        let targetWorldY = tipH;
                        if(isBall || (isDrill && distSq < rSq)) {
                            targetWorldY = tipH + (r - Math.sqrt(Math.max(0, rSq - distSq)));
                        }

                        // Tniemy tylko je≈õli narzƒôdzie jest ni≈ºej ni≈º obecny materia≈Ç
                        if(currentWorldY > targetWorldY) {
                            // Nowy Local Y
                            // newLocalY = targetWorldY - mesh.position.y
                            // newLocalY = targetWorldY - (-stockH/2) = targetWorldY + stockH/2
                            const newLocalY = targetWorldY + stockH/2;
                            
                            // Kolorowanie (0 = g√≥ra, -stockH = d√≥≈Ç)
                            // G≈Çƒôboko≈õƒá skrawania od g√≥ry (0)
                            const depth = -targetWorldY; 
                            const dr = depth/stockH; 
                            const hue = 0.6 - dr*0.6; 
                            const c = new THREE.Color().setHSL(hue, 1.0, 0.5);

                            for(let k=0; k<vertices.length; k++) {
                                const vIdx = vertices[k];
                                posAttr.setY(vIdx, newLocalY);
                                colAttr.setXYZ(vIdx, c.r, c.g, c.b);
                            }
                        }
                    }
                }
            }
            posAttr.needsUpdate=true; colAttr.needsUpdate=true; geo.computeVertexNormals();
        }

        function exportToTXT() {
            if (!state.stockMesh) return;
            let output = "X Y Z\n";
            const pos = state.stockMesh.geometry.attributes.position;
            
            const w = parseFloat(els.stockW.value);
            const d = parseFloat(els.stockD.value);
            const h = parseFloat(els.stockH.value);
            
            state.gridMap.forEach(indices => {
                if(indices.length > 0) {
                    const i = indices[0]; 
                    const ly = pos.getY(i);
                    // World Y = Local Y - h/2
                    const worldY = ly - h/2;
                    
                    // World Coords CNC:
                    const lx = pos.getX(i);
                    const lz = pos.getZ(i);

                    const wx = lx + w/2;
                    const wz = lz - d/2; 
                    // Zapisujemy jako X Y Z, gdzie Z to wysoko≈õƒá (ujemna)
                    output += `${wx.toFixed(3)} ${wz.toFixed(3)} ${worldY.toFixed(3)}\n`;
                }
            });

            const blob = new Blob([output], { type: 'text/plain' });
            const l = document.createElement('a');
            l.href = URL.createObjectURL(blob);
            l.download = 'cnc_cloud.txt';
            l.click();
        }

        function on3DClick(e) {
            const r=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
            raycaster.setFromCamera(mouse, camera);
            let min=Infinity, idx=-1;
            for(let i=0; i<state.segments.length; i++) { const d = raycaster.ray.distanceSqToSegment(state.segments[i].start, state.segments[i].end); if(d<min) { min=d; idx=i; } }
            if(idx!==-1 && min<5) selectSeg(idx);
        }
        function onEditorClick() {
            const l = els.input.value.substring(0, els.input.selectionStart).split('\n').length-1;
            const i = state.segments.findIndex(s => s.lineIdx === l); if(i!==-1) selectSeg(i, false);
        }
        function onSliderScrub(e) {
            state.isPlaying=false; updatePlayUI(); const v = e.target.value/1000; const n = state.segments.length; if(n===0) return;
            let i = Math.floor(v*n); let p = (v*n)-i; if(i>=n) { i=n-1; p=1; }
            const s = state.segments[i]; if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            state.currentSegmentIdx=i; state.progress=p;
            const pos = new THREE.Vector3().lerpVectors(s.start, s.end, p); toolMesh.position.copy(pos); updateDRO(pos);
            els.percent.innerText = `${Math.floor(v*100)}%`; els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            simulateToState(i); if(s.type==='G1') deformStockSegment(s.start, pos, s.toolId);
        }
        function selectSeg(i, scrollEditor=true) {
            if(i<0 || i>=state.segments.length) return; state.currentSegmentIdx=i; state.progress=0; state.isPlaying=false; updatePlayUI();
            const s = state.segments[i]; if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            toolMesh.position.copy(s.start); updateDRO(s.start);
            highlightSelection(s); if(scrollEditor) highlightLineInEditor(s.lineIdx);
            const r = i/state.segments.length; els.percent.innerText = `${Math.floor(r*100)}%`; els.slider.value=r*1000; els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            simulateToState(i);
        }
        function highlightSelection(s) {
            const a = highlightMesh.geometry.attributes.position; a.setXYZ(0, s.start.x, s.start.y, s.start.z); a.setXYZ(1, s.end.x, s.end.y, s.end.z);
            a.needsUpdate=true; highlightMesh.visible=true; highlightSphere.position.copy(s.start); highlightSphere.visible=true;
        }
        function highlightLineInEditor(l) { els.input.scrollTop = (l*20) - (els.input.clientHeight/2); }
        function updatePlayUI() { if(state.isPlaying) { els.iconPlay.classList.add('hidden'); els.iconPause.classList.remove('hidden'); } else { els.iconPlay.classList.remove('hidden'); els.iconPause.classList.add('hidden'); } }

        els.btnPlay.addEventListener('click', () => { if(state.segments.length>0) { if(state.currentSegmentIdx>=state.segments.length-1 && state.progress>=1) { state.currentSegmentIdx=0; state.progress=0; } state.isPlaying=!state.isPlaying; updatePlayUI(); }});
        els.btnReset.addEventListener('click', resetSim); els.btnRender.addEventListener('click', processCode);
        els.btnUpdateStock.addEventListener('click', () => { updateEnvironment(); resetSim(); });
        els.chkInvertY.addEventListener('change', (e) => { state.invertY = e.target.checked; processCode(); });
        els.chkComp.addEventListener('change', (e) => { state.useComp = e.target.checked; processCode(); });
        el('file-upload').addEventListener('change', (e) => { const f=e.target.files[0]; if(!f)return; const r=new FileReader(); r.onload=(ev)=>{els.input.value=ev.target.result; updateLineNumbers(); processCode(); saveData();}; r.readAsText(f); });
        el('cam-iso').addEventListener('click', () => { camera.position.set(120, 150, 200); controls.target.set(50,0,-50); controls.update(); });
        el('cam-top').addEventListener('click', () => { camera.position.set(50, 250, -50); controls.target.set(50,0,-50); controls.update(); });
        
        el('btn-save-local').addEventListener('click', () => { saveData(); alert("Zapisano stan!"); });
        els.btnExportTXT.addEventListener('click', exportToTXT);
        
        els.btnExportSTL.addEventListener('click', () => { 
            const e = new STLExporter(); 
            const r = e.parse(state.stockMesh); 
            const b = new Blob([r], {type:'text/plain'}); 
            const l = document.createElement('a'); 
            l.href = URL.createObjectURL(b); 
            l.download = 'cnc_solid.stl'; 
            l.click(); 
        });

        const sampleMill = `(SOLID CNC TEST v11)\n(Stock: 100x100x20)\n(T1: Glowica 40mm)\n(T2: Frez 10mm)\n(T3: Frez Kulowy 6mm)\n(T4: Wiertlo 5mm)\n(T5: Gwintownik M6)\n\nG0 Z50\nG0 X-20 Y-20\n\n(--- OPERACJA 1: PLANOWANIE T1 ---)\nT1 M6\nG0 Z5\nG0 X-25 Y50\nG1 Z0 F1000\nG1 X125\nG0 Z50\n\n(--- OPERACJA 2: KONTUR G41 T2 ---)\nT2 M6\nG0 X10 Y10\nG0 Z5\nG1 Z-5 F800\nG41 (Kompensacja Lewa)\nG1 X90 Y10\nG1 X90 Y90\nG1 X10 Y90\nG1 X10 Y10\nG40 (Koniec Kompensacji)\nG0 Z50\n\n(--- OPERACJA 3: KIESZEN KOLO T3 ---)\nT3 M6\nG0 X50 Y50\nG0 Z5\nG1 Z-5 F500\n(Spiralne wejscie G3)\nG3 X50 Y50 I15 J0\nG3 X50 Y50 I10 J0\nG0 Z50\n\n(--- OPERACJA 4: WIERCENIE G83 T4 ---)\nT4 M6\nG0 X20 Y20 Z10\nG83 X20 Y20 Z-10 R2 Q3 F200 (Peck Drill)\nG83 X80 Y20 Z-10 R2 Q3\nG80 (Koniec cyklu)\nG0 Z50\n\n(--- OPERACJA 5: GWINTOWANIE G84 T5 ---)\nT5 M6\nG0 X20 Y20 Z10\nG84 X20 Y20 Z-8 R5 F1.0 (Gwint)\nG84 X80 Y20 Z-8 R5\nG80\nG0 Z50\nM30`;
        init();
    </script>
</body>
</html>
