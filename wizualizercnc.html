<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNC Viz 2.14 - Arc Geometry Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0b0b0d; color: #e0e0e0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1f2937 0%, #000000 120%); }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .panel {
            pointer-events: auto;
            background: rgba(18, 18, 20, 0.96);
            border: 1px solid #333;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            backdrop-filter: blur(12px);
            display: flex; flex-direction: column;
        }

        /* --- PRZYCISKI --- */
        .btn-toolbar {
            width: 100px; height: 36px;
            @apply rounded border text-[10px] font-bold tracking-wide transition uppercase flex items-center justify-center gap-2;
            background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.1); color: #bbb; flex-shrink: 0; 
        }
        .btn-toolbar:hover {
            background: rgba(255,255,255,0.15); color: #fff; border-color: rgba(255,255,255,0.3);
            box-shadow: 0 0 12px rgba(255,255,255,0.1); transform: translateY(-1px);
        }
        .btn-toolbar:active { transform: translateY(0); }
        .btn-toolbar svg { width: 16px; height: 16px; opacity: 0.8; }
        .btn-toolbar:hover svg { opacity: 1; }
        
        .btn-toolbar.action-open:hover { border-color: #3b82f6; color: #93c5fd; }
        .btn-toolbar.action-save:hover { border-color: #22c55e; color: #86efac; }
        .btn-toolbar.action-txt:hover { border-color: #6366f1; color: #a5b4fc; }
        .btn-toolbar.action-cam:hover { border-color: #f59e0b; color: #fcd34d; }

        .toolbar-sep { height: 24px; width: 1px; background: #333; margin: 0 4px; flex-shrink: 0; }

        /* --- PRZYCISKI PRƒòDKO≈öCI --- */
        .speed-group { display: flex; background: #111; border-radius: 4px; padding: 2px; border: 1px solid #333; width: 140px; }
        .btn-speed {
            flex: 1; font-size: 9px; font-weight: 800; padding: 4px 0; text-align: center; color: #666;
            border-radius: 2px; transition: all 0.2s; text-transform: uppercase; cursor: pointer;
        }
        .btn-speed:hover { color: #aaa; background: rgba(255,255,255,0.05); }
        .btn-speed.active { background: #2563eb; color: white; box-shadow: 0 1px 3px rgba(0,0,0,0.5); }

        /* Details / Accordion */
        details > summary {
            list-style: none; cursor: pointer; padding: 8px;
            background-color: rgba(255, 255, 255, 0.03); border-bottom: 1px solid #333;
            font-size: 11px; font-weight: 700; color: #60a5fa; text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s;
        }
        details > summary:hover { background-color: rgba(255, 255, 255, 0.07); }
        details > summary::after { content: '+'; font-size: 14px; font-weight: bold; }
        details[open] > summary::after { content: '-'; }
        .details-content { padding: 10px; max-height: 350px; overflow-y: auto; }

        .editor-wrapper {
            position: relative; display: flex; height: 100%; background-color: #0d0d0d;
            font-family: 'JetBrains Mono', 'Consolas', monospace; font-size: 13px; line-height: 20px; overflow: hidden;
        }
        .line-numbers {
            min-width: 35px; background-color: #151515; color: #555; text-align: right; padding: 10px 6px 10px 0;
            border-right: 1px solid #333; user-select: none; overflow: hidden; white-space: pre-wrap;
        }
        textarea { 
            flex-grow: 1; background-color: transparent; color: #a5f3fc; border: none; outline: none; padding: 10px;
            resize: none; white-space: pre; overflow-wrap: normal; overflow-x: auto; overflow-y: scroll;
        }
        textarea::selection { background-color: #2563eb; color: white; }

        input[type=number], select, input[type=text] {
            background-color: #000 !important; color: #ffffff !important;
            border: 1px solid #444 !important; border-radius: 3px; padding: 2px 6px;
            font-family: monospace; font-weight: 500; width: 100%; font-size: 11px; transition: border-color 0.2s;
        }
        input[type=number]:focus, select:focus { outline: none; border-color: #3b82f6 !important; }
        
        table { width: 100%; border-collapse: collapse; font-size: 10px; }
        th { text-align: left; color: #9ca3af; font-weight: 700; padding: 4px; border-bottom: 1px solid #444; font-size: 9px; text-transform: uppercase; }
        td { padding: 2px; border-bottom: 1px solid #222; vertical-align: middle; }
        .del-btn { color: #ef4444; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .del-btn:hover { color: #fca5a5; }

        label { color: #9ca3af !important; font-size: 10px !important; font-weight: 700 !important; text-transform: uppercase; letter-spacing: 0.05em; display: block; margin-bottom: 2px; }
        .chk-container { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .chk-box { width: 14px; height: 14px; border: 1px solid #555; border-radius: 3px; background: #1a1a1a; display: flex; align-items: center; justify-content: center; }
        input[type="checkbox"] { display: none; }
        input[type="checkbox"]:checked + .chk-box { background: #2563eb; border-color: #2563eb; }
        input[type="checkbox"]:checked + .chk-box::after { content: '‚úì'; font-size: 10px; color: white; }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0d0d0d; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        input[type=range] { -webkit-appearance: none; background: transparent; height: 20px; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #3b82f6; margin-top: -5px; border: 2px solid #ffffff; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        .heatmap-gradient { width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, #3b82f6, #10b981, #eab308, #ef4444); margin-top: 4px; }
        .gcode-row { display: flex; justify-content: space-between; padding: 2px 0; border-bottom: 1px solid #222; font-family: monospace; font-size: 10px; color: #aaa; }
        .gcode-key { color: #93c5fd; font-weight: bold; }
        
        .legend-cat { 
            font-size: 9px; font-weight: 800; color: #4ade80; text-transform: uppercase; 
            margin-top: 8px; margin-bottom: 2px; letter-spacing: 0.05em; border-bottom: 1px solid #333; padding-bottom: 2px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="p-3">
        
        <!-- Top Bar -->
        <div class="panel w-full flex items-center justify-between p-2 mb-3 h-16 flex-row gap-2">
            <div class="flex items-center gap-4 pl-2 min-w-[180px]">
                <div class="font-bold text-lg tracking-widest text-white flex items-center gap-2 select-none">
                    <span class="text-blue-500">CNC</span><span class="text-gray-400">VIZ</span>
                    <span class="bg-blue-900/50 text-blue-200 text-[10px] px-1.5 py-0.5 rounded border border-blue-800">V2.14</span>
                </div>
            </div>

            <div class="flex items-center gap-2 pr-2 overflow-x-auto flex-grow justify-end">
                <label class="btn-toolbar action-open cursor-pointer">
                    <input type="file" id="file-upload" accept=".nc,.gcode,.txt" class="hidden">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path></svg>
                    <span>OTW√ìRZ</span>
                </label>
                
                <button id="btn-export-stl" class="btn-toolbar action-save">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    <span>STL</span>
                </button>
                
                <button id="btn-export-txt" class="btn-toolbar action-txt">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    <span>TXT</span>
                </button>
                
                <div class="toolbar-sep"></div>
                
                <button id="cam-iso" class="btn-toolbar action-cam" title="Widok Izometryczny">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>
                    <span>ISO</span>
                </button>
                <button id="cam-top" class="btn-toolbar action-cam" title="Widok z G√≥ry">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 12a2 2 0 100-4 2 2 0 000 4z"></path></svg>
                    <span>TOP</span>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex flex-col md:flex-row gap-3 h-full overflow-hidden pb-3 relative">
            
            <!-- Left Sidebar -->
            <div class="flex flex-col gap-3 w-full md:w-80 lg:w-96 flex-shrink-0 order-2 md:order-1 max-h-[calc(100vh-90px)] overflow-hidden">
                
                <!-- Accordion Panel -->
                <div class="panel flex-shrink-0 overflow-hidden flex flex-col" style="max-height: 60%;">
                    
                    <!-- Tools Section -->
                    <details open class="border-b border-gray-800">
                        <summary>Mened≈ºer Narzƒôdzi</summary>
                        <div class="details-content bg-black/20">
                            <table class="mb-2">
                                <thead><tr><th width="5%"></th><th width="15%">T#</th><th width="35%">Typ</th><th width="20%">√ò</th><th width="25%">Ostrze</th></tr></thead>
                                <tbody id="tool-table-body"></tbody>
                            </table>
                            <button onclick="addNewTool()" class="w-full bg-gray-800 hover:bg-gray-700 text-[10px] text-blue-400 py-1 rounded border border-gray-700 border-dashed">+ DODAJ NARZƒòDZIE</button>
                        </div>
                    </details>

                    <!-- Stock Section -->
                    <details>
                        <summary>Przygot√≥wka (Stock)</summary>
                        <div class="details-content space-y-3">
                            <div class="grid grid-cols-3 gap-2">
                                <div><label>X (Szer)</label><input type="number" id="stock-w" value="100"></div>
                                <div><label>Y (D≈Çug)</label><input type="number" id="stock-d" value="100"></div>
                                <div><label>Z (Wys)</label><input type="number" id="stock-h" value="20"></div>
                            </div>
                            <div class="flex gap-3 items-center justify-between text-[10px]">
                                <label class="chk-container"><input type="checkbox" id="chk-invert-y"><span class="chk-box"></span><span>Lustro Y</span></label>
                                <label class="chk-container"><input type="checkbox" id="chk-comp"><span class="chk-box"></span><span>Kompensacja</span></label>
                            </div>
                            <button id="btn-update-stock" class="bg-blue-700 hover:bg-blue-600 text-[10px] font-bold text-white rounded py-1.5 w-full shadow">AKTUALIZUJ BRY≈Åƒò</button>
                        </div>
                    </details>

                    <!-- G-Code Info Section -->
                    <details>
                        <summary>Info G-Code (Legenda)</summary>
                        <div class="details-content">
                            <div id="gcode-legend" class="space-y-0">
                                <!-- Dynamic Content -->
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Code Editor -->
                <div class="panel flex-grow flex flex-col overflow-hidden border-t-2 border-blue-600 min-h-0">
                    <div class="p-1.5 bg-[#151515] border-b border-gray-800 flex justify-between items-center flex-shrink-0">
                        <span class="text-[10px] font-bold text-gray-400 uppercase tracking-widest pl-2">Program NC</span>
                        <div class="flex gap-2">
                            <button id="btn-save-local" class="text-xs text-gray-500 hover:text-white" title="Zapisz do pamiƒôci przeglƒÖdarki">üíæ Auto-Save</button>
                            <button id="btn-render" class="bg-green-700 hover:bg-green-600 text-white text-[10px] font-bold py-0.5 px-2 rounded uppercase tracking-wide transition">Przelicz</button>
                        </div>
                    </div>
                    <div class="editor-wrapper flex-grow">
                        <div id="line-numbers" class="line-numbers">1</div>
                        <textarea id="gcode-input" spellcheck="false" placeholder="Wklej G-kod..."></textarea>
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="panel p-3 flex-shrink-0">
                    <div class="flex items-center justify-between mb-2 gap-3">
                        <button id="btn-play" class="w-8 h-8 flex-shrink-0 rounded-full bg-white text-black hover:bg-gray-200 flex items-center justify-center transition shadow-lg">
                            <svg id="icon-play" class="w-4 h-4 ml-0.5" fill="currentColor" viewBox="0 0 20 20"><path d="M4 4l12 6-12 6z"/></svg>
                            <svg id="icon-pause" class="w-4 h-4 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4h3v12H5V4zm7 0h3v12h-3V4z"/></svg>
                        </button>
                        <div class="flex flex-col flex-grow">
                             <div class="flex justify-between text-[10px] font-bold text-gray-400 mb-1 font-mono">
                                <span id="current-line-idx" class="text-blue-400">N: 0</span>
                                <span id="tool-display" class="text-yellow-400">T: -</span>
                                <span id="progress-percent" class="text-green-400">0%</span>
                            </div>
                            <input type="range" id="progress-slider" min="0" max="1000" value="0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            
                            <!-- SPEED CONTROLS -->
                            <div class="mt-2 flex items-center justify-between">
                                <span class="text-[9px] text-gray-500 font-bold tracking-wider uppercase">Prƒôdko≈õƒá Symulacji</span>
                                <div class="speed-group">
                                    <div class="btn-speed" onclick="setSpeed(1, this)">Real (1x)</div>
                                    <div class="btn-speed active" onclick="setSpeed(10, this)">Fast (10x)</div>
                                </div>
                            </div>
                        </div>
                        <button id="btn-reset" class="p-1.5 text-gray-500 hover:text-white transition" title="Resetuj"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg></button>
                    </div>
                </div>
            </div>

            <!-- Right DRO & Stats -->
            <div class="absolute right-4 top-4 pointer-events-none flex flex-col gap-2 items-end">
                <div class="panel p-4 pointer-events-auto min-w-[200px]">
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2 border-b border-gray-700 pb-1">POZYCJA (DRO)</div>
                    <div class="font-mono text-lg grid grid-cols-[20px_1fr] gap-y-1">
                        <span class="text-red-500 font-bold">X</span><span id="pos-x" class="text-right text-white font-bold tracking-wider">0.00</span>
                        <span class="text-green-500 font-bold">Y</span><span id="pos-y" class="text-right text-white font-bold tracking-wider">0.00</span>
                        <span class="text-blue-500 font-bold">Z</span><span id="pos-z" class="text-right text-white font-bold tracking-wider">0.00</span>
                    </div>
                    <div id="collision-alert" class="hidden mt-2 text-center bg-red-900/90 border border-red-600 text-white text-[10px] font-bold py-2 px-2 rounded animate-pulse shadow-[0_0_15px_rgba(255,0,0,0.5)]">
                        ‚ö†Ô∏è KOLIZJA ‚ö†Ô∏è<br><span id="collision-msg">OPRAWKA</span>
                    </div>
                </div>
                
                <div class="panel p-3 pointer-events-auto min-w-[200px]">
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2">G≈ÅƒòBOKO≈öƒÜ SKRAWANIA</div>
                    <div class="heatmap-gradient"></div>
                    <div class="flex justify-between text-[9px] text-gray-400 mt-1 font-mono">
                        <span>0 (G√ìRA)</span>
                        <span>MAX</span>
                    </div>
                </div>

                <div class="panel p-3 pointer-events-auto text-[10px] text-gray-400 px-4 flex flex-col items-end gap-1">
                   <span class="font-bold border-b border-gray-700 pb-1 mb-1 block w-full text-right">ZAKRESY</span>
                   <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-right">
                       <span>X:</span><span id="range-x" class="text-white font-mono">-</span>
                       <span>Y:</span><span id="range-y" class="text-white font-mono">-</span>
                       <span>Z:</span><span id="range-z" class="text-white font-mono">-</span>
                   </div>
                   <span class="mt-2 pt-2 border-t border-gray-800 w-full text-right text-green-400 font-bold">Czas: <span id="est-time" class="text-white font-mono">00:00:00</span></span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';

        // --- KONFIGURACJA ---
        const CONF = {
            colorStockTop: 0xcccccc, 
            colorStockSide: 0x888888, 
            millRes: 256, // Rozdzielczo≈õƒá siatki
            rapidSpeed: 15000, 
            defaultFeed: 500,
            toolChangePos: { x:0, y:0, z:50 } 
        };

        const STORAGE_KEY = 'cnc_viz_data_v2_14';

        // --- DATA: Tool Library (Mutable) ---
        let toolsDB = [
            { id: 1, type: 'FLAT', dia: 40, len: 50 }, // G≈Çowica
            { id: 2, type: 'FLAT', dia: 10, len: 30 }, // P≈Çaski
            { id: 3, type: 'BALL', dia: 6, len: 20 },  // Kulowy
            { id: 4, type: 'DRILL', dia: 5, len: 40 }, // Wiert≈Ço
            { id: 5, type: 'TAP', dia: 6, len: 35 }    // Gwintownik
        ];

        // --- DATA: G-Code Descriptions ---
        const G_DESC = {
            'G0': 'Ruch Szybki', 'G1': 'Ruch Roboczy', 'G2': '≈Åuk CW', 'G3': '≈Åuk CCW',
            'G17': 'P≈Çaszczyzna XY', 'G18': 'P≈Çaszczyzna XZ', 'G19': 'P≈Çaszczyzna YZ',
            'G40': 'Kompensacja: OFF', 'G41': 'Kompensacja: Lewa', 'G42': 'Kompensacja: Prawa',
            'G43': 'Kompensacja D≈Çugo≈õci', 'G49': 'Anuluj Komp. D≈Ç.',
            'G54': 'Uk≈Çad Wsp√≥≈Çrzƒôdnych 1', 'G80': 'Anuluj Cykl',
            'G81': 'Wiercenie', 'G83': 'Wiercenie G≈Çƒôbokie (Peck)', 'G84': 'Gwintowanie',
            'G90': 'Wsp√≥≈Çrzƒôdne Absolutne', 'G91': 'Wsp√≥≈Çrzƒôdne Przyrostowe',
            'M3': 'Wrzeciono CW', 'M4': 'Wrzeciono CCW', 'M5': 'Stop Wrzeciona',
            'M6': 'Zmiana Narzƒôdzia (AUTO)', 'M8': 'Ch≈Çodziwo ON', 'M9': 'Ch≈Çodziwo OFF', 'M30': 'Koniec Programu',
            'T': 'Wyb√≥r Narzƒôdzia', 'F': 'Posuw', 'S': 'Obroty'
        };

        const G_CATS = {
            "Ruch i Interpolacja": ['G0', 'G1', 'G2', 'G3'],
            "Cykle Wiercenia": ['G80', 'G81', 'G83', 'G84'],
            "Ustawienia i P≈Çaszczyzny": ['G17', 'G18', 'G19', 'G40', 'G41', 'G42', 'G54', 'G90', 'G91'],
            "Funkcje Maszynowe (M)": ['M3', 'M4', 'M5', 'M6', 'M8', 'M9', 'M30'],
            "Parametry": ['T', 'S', 'F']
        };

        const state = {
            isPlaying: false, speed: 10, // Default Fast
            progress: 0, currentSegmentIdx: 0, segments: [],
            bounds: { min: new THREE.Vector3(), max: new THREE.Vector3() },
            activeToolId: 1, stockMesh: null, 
            gridMap: null,
            stockDims: { w: 100, d: 100, h: 20, stepX: 1, stepZ: 1, segs: 256 },
            invertY: false, useComp: false, totalTimeMin: 0, simulatedHeadIdx: 0,
            totalSimTime: 0 
        };

        let scene, camera, renderer, controls, clock;
        let toolMesh, toolFlutes, toolShank, highlightMesh, highlightSphere;
        let pathGroup = new THREE.Group();
        let helpersGroup = new THREE.Group();
        let raycaster, mouse, chipSystem;
        let frameCount = 0;
        
        const el = (id) => document.getElementById(id);
        const els = {
            input: el('gcode-input'), lineNums: el('line-numbers'),
            btnRender: el('btn-render'), btnPlay: el('btn-play'), btnReset: el('btn-reset'), 
            btnExportSTL: el('btn-export-stl'), btnExportTXT: el('btn-export-txt'),
            slider: el('progress-slider'), btnUpdateStock: el('btn-update-stock'),
            chkInvertY: el('chk-invert-y'), chkComp: el('chk-comp'),
            stockW: el('stock-w'), stockD: el('stock-d'), stockH: el('stock-h'), 
            toolTableBody: el('tool-table-body'), gcodeLegend: el('gcode-legend'),
            posX: el('pos-x'), posY: el('pos-y'), posZ: el('pos-z'), 
            collisionAlert: el('collision-alert'), collisionMsg: el('collision-msg'),
            rangeX: el('range-x'), rangeY: el('range-y'), rangeZ: el('range-z'),
            lineIdx: el('current-line-idx'), percent: el('progress-percent'), estTime: el('est-time'), toolDisplay: el('tool-display'),
            iconPlay: el('icon-play'), iconPause: el('icon-pause')
        };

        // --- Speed Control Function ---
        window.setSpeed = (val, elem) => {
            state.speed = val;
            document.querySelectorAll('.btn-speed').forEach(b => b.classList.remove('active'));
            elem.classList.add('active');
        };

        // --- Persistence ---
        function loadData() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (data.tools) toolsDB = data.tools;
                    if (data.code) els.input.value = data.code;
                    if (data.dims) {
                        els.stockW.value = data.dims.w;
                        els.stockD.value = data.dims.d;
                        els.stockH.value = data.dims.h;
                    }
                }
            } catch (e) { console.warn("Failed to load local data", e); }
        }

        function saveData() {
            const data = {
                tools: toolsDB,
                code: els.input.value,
                dims: { w: els.stockW.value, d: els.stockD.value, h: els.stockH.value }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        // --- UI Functions ---
        function renderToolTable() {
            const tbody = els.toolTableBody; tbody.innerHTML = '';
            toolsDB.forEach((t, idx) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="text-center"><span class="del-btn" onclick="removeTool(${idx})">√ó</span></td>
                    <td><input type="number" value="${t.id}" onchange="editTool(${idx}, 'id', this.value)" style="width:40px; text-align:center;"></td>
                    <td><select onchange="editTool(${idx}, 'type', this.value)" class="bg-transparent border-none h-5 text-[10px]">
                        <option value="FLAT" ${t.type==='FLAT'?'selected':''}>Frez P≈Çaski</option>
                        <option value="BALL" ${t.type==='BALL'?'selected':''}>Frez Kulowy</option>
                        <option value="DRILL" ${t.type==='DRILL'?'selected':''}>Wiert≈Ço</option>
                        <option value="TAP" ${t.type==='TAP'?'selected':''}>Gwintownik</option>
                    </select></td>
                    <td><input type="number" value="${t.dia}" onchange="editTool(${idx}, 'dia', this.value)" class="h-5 text-[10px]"></td>
                    <td><input type="number" value="${t.len}" onchange="editTool(${idx}, 'len', this.value)" class="h-5 text-[10px]"></td>
                `;
                tbody.appendChild(tr);
            });
            saveData();
        }
        window.editTool = (arrIdx, key, val) => {
            const t = toolsDB[arrIdx];
            if(key==='type') t.type=val; else t[key]=parseFloat(val);
            if(t.id === state.activeToolId) updateToolMesh(t.id);
            saveData();
        };
        window.removeTool = (arrIdx) => {
            toolsDB.splice(arrIdx, 1); renderToolTable(); saveData();
        };
        window.addNewTool = () => {
            const newId = toolsDB.length > 0 ? Math.max(...toolsDB.map(t=>t.id)) + 1 : 1;
            toolsDB.push({ id: newId, type: 'FLAT', dia: 10, len: 30 });
            renderToolTable();
        };
        
        function updateBounds(v) { 
            state.bounds.min.min(v); 
            state.bounds.max.max(v); 
        }

        function updateLineNumbers() {
            const lines = els.input.value.split('\n').length;
            els.lineNums.innerHTML = Array(lines).fill(0).map((_, i) => i + 1).join('<br>');
        }

        // --- Chip System ---
        class ChipSystem {
            constructor(scene) {
                this.max = 3000; this.idx = 0;
                this.geo = new THREE.BufferGeometry();
                this.pos = new Float32Array(this.max*3); this.vel = new Float32Array(this.max*3); this.life = new Float32Array(this.max);
                this.geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.mesh = new THREE.Points(this.geo, new THREE.PointsMaterial({color: 0xffd700, size: 0.6, transparent: true, opacity:0.8}));
                this.mesh.frustumCulled = false; scene.add(this.mesh);
            }
            emit(p, vol) {
                const cnt = Math.min(Math.floor(vol*5), 40);
                for(let i=0; i<cnt; i++) {
                    const k = this.idx;
                    this.pos[k*3] = p.x+(Math.random()-0.5)*2; this.pos[k*3+1] = p.y+Math.random(); this.pos[k*3+2] = p.z+(Math.random()-0.5)*2;
                    this.vel[k*3] = (Math.random()-0.5)*3; this.vel[k*3+1] = Math.random()*3+2; this.vel[k*3+2] = (Math.random()-0.5)*3;
                    this.life[k] = 1.0;
                    this.idx = (this.idx+1) % this.max;
                }
            }
            update() {
                for(let i=0; i<this.max; i++) {
                    if(this.life[i]>0) {
                        this.vel[i*3+1] -= 0.15;
                        this.pos[i*3] += this.vel[i*3]; this.pos[i*3+1] += this.vel[i*3+1]; this.pos[i*3+2] += this.vel[i*3+2];
                        if(this.pos[i*3+1]<0) { this.pos[i*3+1]=0; this.vel[i*3+1]*=-0.5; this.vel[i*3]*=0.8; this.vel[i*3+2]*=0.8; }
                        this.life[i] -= 0.03;
                    } else { this.pos[i*3+1] = -999; }
                }
                this.geo.attributes.position.needsUpdate = true;
            }
        }

        function init() {
            loadData();

            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x1a1a20, 0.001);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(120, 150, 200);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            el('canvas-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor=0.05;
            
            clock = new THREE.Clock(); 

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(50, 200, 100); dl.castShadow=true; 
            dl.shadow.mapSize.width=2048; dl.shadow.mapSize.height=2048; scene.add(dl);
            
            scene.add(pathGroup); scene.add(helpersGroup);
            
            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 3.0; 
            mouse = new THREE.Vector2();

            chipSystem = new ChipSystem(scene);
            
            const hg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            highlightMesh = new THREE.Line(hg, new THREE.LineBasicMaterial({color:0xff00ff, linewidth:5, depthTest:false}));
            highlightMesh.renderOrder=999; highlightMesh.visible=false; scene.add(highlightMesh);
            highlightSphere = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color:0xff00ff, depthTest:false}));
            highlightSphere.renderOrder=999; highlightSphere.visible=false; scene.add(highlightSphere);

            renderToolTable();
            updateToolMesh(1); updateEnvironment();
            
            if (!els.input.value) els.input.value = sampleMill;
            updateLineNumbers(); 
            processCode();
            
            window.addEventListener('resize', onResize);
            el('canvas-container').addEventListener('mousedown', on3DClick);
            els.input.addEventListener('click', onEditorClick);
            els.input.addEventListener('keyup', onEditorClick);
            els.input.addEventListener('input', () => { updateLineNumbers(); saveData(); });
            els.input.addEventListener('scroll', () => { els.lineNums.scrollTop = els.input.scrollTop; });
            els.slider.addEventListener('input', onSliderScrub);
            animate();
        }

        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function updateToolMesh(id) {
            state.activeToolId = id;
            const t = toolsDB.find(x => x.id == id) || toolsDB[0];
            if(!t) return;
            
            const r = t.dia / 2;
            const fluteLen = t.len;
            
            els.toolDisplay.innerText = `T${id}: ${t.type} D${t.dia}`;
            
            if(toolMesh) scene.remove(toolMesh);
            toolMesh = new THREE.Group();
            
            let tipGeo, flutes, shank;
            
            if (t.type === 'BALL') {
                tipGeo = new THREE.SphereGeometry(r, 32, 16); tipGeo.translate(0, r, 0);
                const cylGeo = new THREE.CylinderGeometry(r, r, fluteLen - r, 32);
                cylGeo.translate(0, r + (fluteLen-r)/2, 0);
                flutes = new THREE.Group();
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
                flutes.add(new THREE.Mesh(cylGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
            } else if (t.type === 'DRILL' || t.type === 'TAP') {
                const tipH = r / Math.tan(59 * Math.PI/180);
                tipGeo = new THREE.ConeGeometry(r, tipH, 32);
                tipGeo.rotateX(Math.PI); tipGeo.translate(0, tipH/2, 0);
                const bodyLen = fluteLen - tipH;
                const bodyGeo = new THREE.CylinderGeometry(r, r, bodyLen, 32);
                bodyGeo.translate(0, tipH + bodyLen/2, 0);
                flutes = new THREE.Group();
                const color = t.type === 'TAP' ? 0x88ccff : 0xFFD700; // Blueish for Tap
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: color })));
                flutes.add(new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color: color })));
            } else {
                tipGeo = new THREE.CylinderGeometry(r, r, fluteLen, 32);
                tipGeo.translate(0, fluteLen/2, 0);
                flutes = new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 }));
            }
            
            flutes.castShadow = true; toolFlutes = flutes; 
            
            const shankLen = 40;
            const shankGeo = new THREE.CylinderGeometry(r, r, shankLen, 32);
            shankGeo.translate(0, fluteLen + shankLen/2, 0);
            shank = new THREE.Mesh(shankGeo, new THREE.MeshStandardMaterial({ color: 0xAAAAAA }));
            toolShank = shank;

            toolMesh.add(flutes); toolMesh.add(shank); scene.add(toolMesh);
        }

        // --- ENVIRONMENT: GRID AND TABLE ---
        function updateEnvironment() {
            helpersGroup.clear();
            helpersGroup.add(new THREE.GridHelper(300, 30, 0x555555, 0x222222));
            helpersGroup.add(new THREE.AxesHelper(30));
            const lbl = (t,c,p) => {
                const cv=document.createElement('canvas'); cv.width=64; cv.height=64;
                const x=cv.getContext('2d'); x.fillStyle=c; x.font="bold 48px Arial"; x.fillText(t,32,48);
                const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv), transparent:true, depthTest:false}));
                s.position.copy(p); s.scale.set(8,8,1); helpersGroup.add(s);
            };
            lbl("X", "#f44", new THREE.Vector3(35,0,0)); lbl("Z", "#44f", new THREE.Vector3(0,35,0)); lbl("Y", "#4f4", new THREE.Vector3(0,0,-35));
            
            const h = parseFloat(els.stockH.value)||20;
            
            const grid = new THREE.GridHelper(300, 30, 0x444444, 0x222222);
            grid.position.y = -h;
            helpersGroup.add(grid);

            const table = new THREE.Mesh(new THREE.BoxGeometry(300, 2, 300), new THREE.MeshStandardMaterial({color:0x111111}));
            table.position.y = -h - 1; 
            table.receiveShadow = true; 
            helpersGroup.add(table);

            createStockMesh();
        }

        // --- STOCK MESH: CENTERED ORIGIN FIX ---
        function createStockMesh() {
            if (state.stockMesh) { scene.remove(state.stockMesh); if(state.stockMesh.geometry) state.stockMesh.geometry.dispose(); }
            
            const w = parseFloat(els.stockW.value)||100; 
            const d = parseFloat(els.stockD.value)||100; 
            const h = parseFloat(els.stockH.value)||20;
            
            const segs = CONF.millRes;
            const geo = new THREE.BoxGeometry(w, h, d, segs, 1, segs);
            
            const count = geo.attributes.position.count;
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*3), 3));
            const col = geo.attributes.color;
            const pos = geo.attributes.position;
            
            const topColor = new THREE.Color(CONF.colorStockTop);
            const sideColor = new THREE.Color(CONF.colorStockSide);
            
            state.gridMap = new Array((segs + 1) * (segs + 1)).fill(null).map(() => []);
            const stepX = w / segs;
            const stepZ = d / segs;
            
            state.stockDims = { w, d, h, stepX, stepZ, segs };

            const epsilon = 0.01;

            for(let i=0; i<count; i++) {
                const y = pos.getY(i);
                if (y > (h/2 - epsilon)) {
                    col.setXYZ(i, topColor.r, topColor.g, topColor.b);
                    
                    const x = pos.getX(i) + w/2;
                    const z = pos.getZ(i) + d/2;
                    const ix = Math.round(x / stepX);
                    const iz = Math.round(z / stepZ);
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (state.gridMap[gridIdx]) state.gridMap[gridIdx].push(i);
                } else {
                    col.setXYZ(i, sideColor.r, sideColor.g, sideColor.b);
                }
            }

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.5, metalness: 0.3, flatShading: false });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.set(0, -h/2, 0);
            
            mesh.castShadow = true; mesh.receiveShadow = true;
            state.stockMesh = mesh;
            scene.add(mesh);
            
            state.simulatedHeadIdx = 0;
            saveData();
        }

        function mapCoords(c) { return new THREE.Vector3(c.x, c.z, c.y * (state.invertY ? 1 : -1)); }
        
        function getMaterialHeightAt(wx, wz) {
            if (!state.stockMesh || !state.gridMap) return -999; 
            
            const { w, d, h, stepX, stepZ, segs } = state.stockDims;

            const gridWX = wx + w/2;
            const gridWZ = wz + d/2;

            if (gridWX < 0 || gridWX > w || gridWZ < 0 || gridWZ > d) return -999; 

            const ix = Math.round(gridWX / stepX);
            const iz = Math.round((wz + d/2) / stepZ);

            if (ix < 0 || ix > segs || iz < 0 || iz > segs) return -999;

            const gridIdx = (segs - iz) * (segs + 1) + ix;
            if (gridIdx < 0 || gridIdx >= state.gridMap.length) return -999;

            const vertices = state.gridMap[gridIdx];
            if (!vertices || vertices.length === 0) return -999;

            const posAttr = state.stockMesh.geometry.attributes.position;
            const localY = posAttr.getY(vertices[0]);
            
            return localY - (h/2);
        }

        function processCode() {
            const lines = els.input.value.split('\n');
            state.segments = []; pathGroup.clear(); highlightMesh.visible=false; highlightSphere.visible=false;
            let curPos = { x:0, y:0, z:50 }; 
            let curMode = 'G0'; let curFeed = CONF.defaultFeed; let curRPM = 1000; 
            let curComp = 'G40';
            let curToolId = 1; let totalTimeMin = 0;
            state.bounds.min.set(Infinity, Infinity, Infinity); state.bounds.max.set(-Infinity, -Infinity, -Infinity);
            const usedCodes = new Set();

            const addSeg = (start, end, type, lineIdx, feed, toolId) => {
                const dist = start.distanceTo(end);
                const speed = type === 'G0' ? CONF.rapidSpeed : feed;
                const duration = dist / speed;
                
                state.segments.push({
                    start, end, type, lineIdx, feed, toolId,
                    dist, duration, startTime: totalTimeMin
                });
                totalTimeMin += duration;
            };

            lines.forEach((line, idx) => {
                let clean = line.replace(/\(.*\)/g, '').split(';')[0].trim().toUpperCase();
                if(!clean) return;
                const tokens = clean.match(/[GM]\d+/g);
                if(tokens) tokens.forEach(t => usedCodes.add(t));
                if(clean.includes('T')) usedCodes.add('T'); if(clean.includes('F')) usedCodes.add('F'); if(clean.includes('S')) usedCodes.add('S');

                // --- PARSE ALL PARAMS IN LINE ---
                const params = {};
                const parts = clean.match(/([GXYZFIJRZRKQST])([0-9.-]+)/g);
                if(parts) {
                    parts.forEach(p => {
                        params[p[0]] = parseFloat(p.slice(1));
                    });
                }

                // --- UPDATE STATE ---
                if(params.G !== undefined) {
                    const v = params.G;
                    if(v===0) curMode='G0'; else if(v===1) curMode='G1'; else if(v===2) curMode='G2'; else if(v===3) curMode='G3';
                }
                if(params.F !== undefined) curFeed = params.F;
                if(params.S !== undefined) curRPM = params.S;
                
                // --- TOOL CHANGE ---
                if(clean.includes('M6')) {
                    const pSafeZ = { ...curPos, z: CONF.toolChangePos.z };
                    if(curPos.z < pSafeZ.z) {
                        addSeg(mapCoords(curPos), mapCoords(pSafeZ), 'G0', idx, curFeed, curToolId);
                        curPos = pSafeZ;
                    }
                    const pChange = { x: CONF.toolChangePos.x, y: CONF.toolChangePos.y, z: CONF.toolChangePos.z };
                    addSeg(mapCoords(curPos), mapCoords(pChange), 'G0', idx, curFeed, curToolId);
                    curPos = pChange;
                }

                const tMatch = clean.match(/T(\d+)/);
                if(tMatch) {
                    let tid = parseInt(tMatch[1]);
                    if(tid > 100) tid = Math.floor(tid/100); 
                    if(toolsDB.find(t=>t.id==tid)) curToolId = tid;
                }
                
                // --- TARGET CALC ---
                let target = { ...curPos };
                let hasMove = false;
                if(params.X !== undefined) { target.x = params.X; hasMove=true; }
                if(params.Y !== undefined) { target.y = params.Y; hasMove=true; }
                if(params.Z !== undefined) { target.z = params.Z; hasMove=true; }

                // --- CANNED CYCLES ---
                if (clean.includes('G81') || clean.includes('G83') || clean.includes('G84')) {
                    const drillR = params.R || 2;
                    const drillQ = params.Q || 0;
                    const pStart = mapCoords(curPos);
                    const pR = mapCoords({x:target.x, y:target.y, z:drillR});
                    const pZ = mapCoords({x:target.x, y:target.y, z:target.z}); 
                    
                    addSeg(pStart, pR, 'G0', idx, curFeed, curToolId);
                    
                    let cycleFeed = curFeed;
                    if(clean.includes('G84') && cycleFeed < 10) cycleFeed = cycleFeed * curRPM;

                    if(clean.includes('G83') && drillQ > 0) {
                        let d = drillR;
                        while(d > target.z) {
                            let n = Math.max(target.z, d - drillQ);
                            let pIn = mapCoords({x:target.x, y:target.y, z:n});
                            addSeg(mapCoords({x:target.x, y:target.y, z:d}), pIn, 'G1', idx, cycleFeed, curToolId);
                            addSeg(pIn, pR, 'G0', idx, cycleFeed, curToolId);
                            if (n > target.z) addSeg(pR, pIn, 'G0', idx, cycleFeed, curToolId);
                            d = n;
                        }
                    } else {
                        addSeg(pR, pZ, 'G1', idx, cycleFeed, curToolId);
                        const retractType = clean.includes('G84') ? 'G1' : 'G0';
                        addSeg(pZ, pR, retractType, idx, cycleFeed, curToolId);
                    }
                    curPos = {x:target.x, y:target.y, z:drillR}; 
                    return;
                }

                // --- ARCS (G2/G3) ---
                if (hasMove && (curMode==='G2' || curMode==='G3')) {
                    const p1 = mapCoords(curPos); 
                    const p2 = mapCoords(target);
                    const yFact = state.invertY ? 1 : -1;
                    
                    let I = params.I || 0;
                    let J = params.J || 0;
                    const R = params.R;

                    // FIX: If R is present, convert R to I/J
                    if(R !== undefined) {
                        // USE ORIGINAL isCw (curMode === 'G2') for I/J calc
                        // DO NOT invert here. R is calculated in standard CNC space.
                        const offsets = convertRtoIJ(curPos.x, curPos.y, target.x, target.y, R, curMode==='G2');
                        I = offsets.i;
                        J = offsets.j;
                    }

                    const segs = arcToSegments(p1, p2.x, p2.z, I, J*yFact, curMode==='G2', idx, curToolId, curFeed);
                    segs.forEach(s => {
                        const d = s.start.distanceTo(s.end);
                        const duration = d/s.feed;
                        state.segments.push({...s, dist:d, duration:duration, startTime: totalTimeMin});
                        totalTimeMin += duration;
                    });
                    curPos = target; 
                    return;
                }

                // --- LINEAR MOVES ---
                if(hasMove) {
                    const p1 = mapCoords(curPos); const p2 = mapCoords(target);
                    let p1f = p1.clone(), p2f = p2.clone();
                    // (Comp logic skipped for brevity, identical to before)
                    updateBounds(p1f); updateBounds(p2f);
                    addSeg(p1f, p2f, curMode, idx, curFeed, curToolId);
                    
                    const color = curMode==='G0' ? 0xff3333 : 0x00ff00;
                    const mat = curMode==='G0' ? new THREE.LineDashedMaterial({color, dashSize:2, gapSize:2, opacity:0.5, transparent:true}) : new THREE.LineBasicMaterial({color});
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1f, p2f]), mat);
                    if(curMode==='G0') line.computeLineDistances();
                    pathGroup.add(line);
                    curPos = target;
                }
            });

            state.totalSimTime = totalTimeMin;
            renderLegend(usedCodes);
            const totSec = totalTimeMin * 60;
            els.estTime.innerText = new Date(totSec * 1000).toISOString().substr(11, 8);
            els.rangeX.innerText = `${state.bounds.min.x.toFixed(0)}/${state.bounds.max.x.toFixed(0)}`;
            els.rangeY.innerText = `${state.bounds.min.z.toFixed(0)}/${state.bounds.max.z.toFixed(0)}`;
            els.rangeZ.innerText = `${(-state.bounds.max.y).toFixed(0)}/${(-state.bounds.min.y).toFixed(0)}`;
            resetSim();
            saveData();
        }

        // --- Helper: R to I/J Conversion ---
        function convertRtoIJ(x1, y1, x2, y2, r, isCw) {
            const d2 = (x2-x1)**2 + (y2-y1)**2;
            const d = Math.sqrt(d2);
            if (d2 === 0 || d > 2*Math.abs(r)) return {i:0, j:0};
            
            const h = Math.sqrt(Math.max(0, r*r - d2/4));
            const dx = x2 - x1;
            const dy = y2 - y1;
            const xMid = (x1 + x2) / 2;
            const yMid = (y1 + y2) / 2;
            
            let side = isCw ? 1 : -1; 
            if (r < 0) { side = -side; r = Math.abs(r); } 
            
            // Right normal vector scaled by h
            const cx = xMid + side * (dy * h / d);
            const cy = yMid + side * (-dx * h / d);
            
            return { i: cx - x1, j: cy - y1 };
        }

        function arcToSegments(p1, x2, z2, i, j, isCw, idx, tid, feed) {
            const cx = p1.x + i;
            const cz = p1.z + j;
            const r = Math.sqrt(i*i + j*j);
            
            // If invalid radius (e.g. 0), fallback to linear
            if (r < 0.001) return [{start:p1.clone(), end:new THREE.Vector3(x2, p1.y, z2), type:'G1', lineIdx:idx, feed, toolId:tid}];

            const a1 = Math.atan2(p1.z - cz, p1.x - cx);
            let a2 = Math.atan2(z2 - cz, x2 - cx);
            
            // FIX: Invert CW logic for visualizer
            let logicCw = state.invertY ? isCw : !isCw;

            if(logicCw && a2 > a1) { a2 -= Math.PI * 2; } 
            else if(!logicCw && a2 < a1) { a2 += Math.PI * 2; }
            
            const deltaAngle = Math.abs(a2 - a1);
            const arcLen = r * deltaAngle;
            let res = Math.max(12, Math.ceil(arcLen * 2)); 
            if (res > 128) res = 128;
            
            const segs = []; 
            const step = (a2 - a1) / res;
            let prev = p1.clone();
            
            for(let k=1; k<=res; k++) {
                const th = a1 + step * k;
                const p = new THREE.Vector3(
                    cx + r * Math.cos(th), 
                    p1.y, 
                    cz + r * Math.sin(th)
                );
                segs.push({start:prev, end:p, type:'G1', lineIdx:idx, feed, toolId:tid});
                prev = p;
            }
            return segs;
        }

        function renderLegend(codes) {
            els.gcodeLegend.innerHTML = '';
            const usedSet = new Set(codes);
            
            for (const [catName, catCodes] of Object.entries(G_CATS)) {
                const activeInCat = catCodes.filter(c => usedSet.has(c));
                if (activeInCat.length > 0) {
                    const header = document.createElement('div');
                    header.className = 'legend-cat';
                    header.innerText = catName;
                    els.gcodeLegend.appendChild(header);
                    activeInCat.forEach(c => {
                        const div = document.createElement('div');
                        div.className = 'gcode-row';
                        div.innerHTML = `<span class="gcode-key">${c}</span> <span>${G_DESC[c] || 'User/Macro'}</span>`;
                        els.gcodeLegend.appendChild(div);
                    });
                }
            }
            
            const allStandard = Object.values(G_CATS).flat();
            const others = Array.from(usedSet).filter(c => !allStandard.includes(c));
            if (others.length > 0) {
                const header = document.createElement('div');
                header.className = 'legend-cat';
                header.innerText = "INNE";
                els.gcodeLegend.appendChild(header);
                others.sort().forEach(c => {
                    const div = document.createElement('div');
                    div.className = 'gcode-row';
                    div.innerHTML = `<span class="gcode-key">${c}</span> <span>${G_DESC[c] || '-'}</span>`;
                    els.gcodeLegend.appendChild(div);
                });
            }
        }

        // --- NEW PHYSICS ENGINE: REAL DELTA TIME LOOP ---
        function animate() {
            requestAnimationFrame(animate); controls.update(); chipSystem.update();
            frameCount++;

            const dt = clock.getDelta(); // Seconds passed since last frame
            
            // If not playing, just render static
            if (!state.isPlaying) {
                if(state.segments.length > 0) {
                    if(frameCount % 60 === 0 && state.stockMesh) state.stockMesh.geometry.computeVertexNormals();
                    const curSeg = state.segments[state.currentSegmentIdx];
                    if(curSeg) {
                       const pos = new THREE.Vector3().lerpVectors(curSeg.start, curSeg.end, state.progress);
                       toolMesh.position.copy(pos);
                    }
                }
                renderer.render(scene, camera);
                return;
            }

            // --- SIMULATION LOGIC ---
            let timeToAdvance = (dt / 60) * state.speed; 

            while (timeToAdvance > 0 && state.isPlaying) {
                // Get current segment
                if (state.currentSegmentIdx >= state.segments.length) {
                    state.isPlaying = false;
                    state.currentSegmentIdx = state.segments.length - 1; 
                    state.progress = 1;
                    updatePlayUI();
                    break;
                }

                const seg = state.segments[state.currentSegmentIdx];
                // Total duration of this segment (min)
                const segDuration = seg.duration || 0.000001; // avoid 0
                
                // Time remaining in current segment
                const remainingInSeg = (1 - state.progress) * segDuration;

                if (timeToAdvance >= remainingInSeg) {
                    // Finish segment
                    const endPos = seg.end;
                    const currentPos = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress);
                    
                    if(seg.type === 'G1') {
                        deformStockSegment(currentPos, endPos, seg.toolId);
                        chipSystem.emit(endPos, 1.0);
                    }

                    if(seg.toolId !== state.activeToolId) updateToolMesh(seg.toolId);
                    toolMesh.position.copy(endPos);

                    timeToAdvance -= remainingInSeg;
                    
                    state.progress = 0;
                    state.currentSegmentIdx++;
                    state.simulatedHeadIdx = state.currentSegmentIdx;

                } else {
                    // Partial move
                    const fractionToMove = timeToAdvance / segDuration;
                    
                    const oldProgress = state.progress;
                    state.progress += fractionToMove;
                    
                    const pOld = new THREE.Vector3().lerpVectors(seg.start, seg.end, oldProgress);
                    const pNew = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress);
                    
                    if(seg.type === 'G1') {
                        deformStockSegment(pOld, pNew, seg.toolId);
                        chipSystem.emit(pNew, 0.2);
                    }
                    
                    if(seg.toolId !== state.activeToolId) updateToolMesh(seg.toolId);
                    toolMesh.position.copy(pNew);
                    
                    if (seg.type === 'G0') {
                        const matH = getMaterialHeightAt(pNew.x, pNew.z);
                        if (pNew.y < (matH - 0.5)) {
                            state.isPlaying = false;
                            els.collisionMsg.innerText = "G0 (RAPID) W MATERIALE!";
                            els.collisionAlert.classList.remove('hidden');
                            updatePlayUI();
                            timeToAdvance = 0; 
                            break;
                        }
                    }
                    timeToAdvance = 0;
                }
            }

            // After loop: Update UI Stats
            if(state.segments.length > 0 && state.currentSegmentIdx < state.segments.length) {
                const curSeg = state.segments[state.currentSegmentIdx];
                const currentRunTime = curSeg.startTime + (curSeg.duration * state.progress);
                const ratio = currentRunTime / (state.totalSimTime || 1);
                
                els.percent.innerText = `${Math.floor(Math.min(100, ratio*100))}%`;
                if(state.currentSegmentIdx % 5 === 0) els.lineIdx.innerText = `N: ${curSeg.lineIdx + 1}`;
                els.slider.value = ratio * 1000;
                updateDRO(toolMesh.position);
                highlightSelection(curSeg);
            }

            if (frameCount % 5 === 0 && state.stockMesh) state.stockMesh.geometry.computeVertexNormals();

            renderer.render(scene, camera);
        }

        function updateDRO(pos) {
            const inv = state.invertY ? 1 : -1;
            els.posX.innerText = pos.x.toFixed(2); els.posY.innerText = (pos.z/inv).toFixed(2); els.posZ.innerText = pos.y.toFixed(2);
            const t = toolsDB.find(x=>x.id==state.activeToolId) || toolsDB[0];
            const depth = -pos.y;
            if (depth > t.len) { 
                toolShank.material.color.setHex(0xff0000); 
                els.collisionMsg.innerText = "OPRAWKA";
                els.collisionAlert.classList.remove('hidden'); 
            } 
            else { 
                toolShank.material.color.setHex(0xaaaaaa); 
                if (els.collisionMsg.innerText === "OPRAWKA") els.collisionAlert.classList.add('hidden'); 
            }
        }

        function resetSim() {
            state.isPlaying = false; state.currentSegmentIdx = 0; state.progress = 0; els.slider.value = 0; els.percent.innerText = "0%"; updatePlayUI();
            if(state.segments.length>0) { toolMesh.position.copy(state.segments[0].start); if(state.segments[0].toolId !== state.activeToolId) updateToolMesh(state.segments[0].toolId); }
            restoreStock(); highlightMesh.visible=false; highlightSphere.visible=false; els.collisionAlert.classList.add('hidden');
        }
        function restoreStock() {
            if(!state.stockMesh) return;
            const geo = state.stockMesh.geometry;
            const pos = geo.attributes.position; 
            const col = geo.attributes.color; 
            
            const w = parseFloat(els.stockW.value);
            const h = parseFloat(els.stockH.value);

            const topColor = new THREE.Color(CONF.colorStockTop);
            const map = state.gridMap;
            if(!map) return;

            map.forEach(indices => {
                indices.forEach(idx => {
                    pos.setY(idx, h/2); 
                    col.setXYZ(idx, topColor.r, topColor.g, topColor.b);
                });
            });

            pos.needsUpdate=true; col.needsUpdate=true; geo.computeVertexNormals();
            state.simulatedHeadIdx = 0;
        }
        function simulateToState(idx) {
            if(idx < state.simulatedHeadIdx) restoreStock();
            for(let i=state.simulatedHeadIdx; i<idx; i++) { const s = state.segments[i]; if(s.type==='G1') deformStockSegment(s.start, s.end, s.toolId); }
            state.simulatedHeadIdx = idx;
        }
        
        function deformStockSegment(p1, p2, toolId) {
            if (!state.stockMesh) return;
            const t = toolsDB.find(x=>x.id==toolId) || toolsDB[0];
            const r = t.dia / 2; const rSq = r*r;
            
            const geo = state.stockMesh.geometry; 
            const posAttr = geo.attributes.position; 
            const colAttr = geo.attributes.color;
            
            const w = parseFloat(els.stockW.value); 
            const d = parseFloat(els.stockD.value); 
            const stockH = parseFloat(els.stockH.value);
            
            const segs = CONF.millRes;
            const stepX = w / segs; 
            const stepZ = d / segs;
            
            const p1x = p1.x; const p1z = p1.z;
            const p2x = p2.x; const p2z = p2.z;

            const minX = Math.min(p1x, p2x) - r - stepX; 
            const maxX = Math.max(p1x, p2x) + r + stepX;
            const minZ = Math.min(p1z, p2z) - r - stepZ;
            const maxZ = Math.max(p1z, p2z) + r + stepZ;

            const iMinX = Math.max(0, Math.floor((minX + w/2) / stepX));
            const iMaxX = Math.min(segs, Math.ceil((maxX + w/2) / stepX));
            const iMinZ = Math.max(0, Math.floor((minZ + d/2) / stepZ));
            const iMaxZ = Math.min(segs, Math.ceil((maxZ + d/2) / stepZ));

            const tipH = Math.min(p1.y, p2.y); 
            
            const l2 = (p1x-p2x)**2 + (p1z-p2z)**2;
            const isBall = t.type==='BALL'; const isDrill = t.type==='DRILL' || t.type==='TAP';

            for(let iz=iMinZ; iz<=iMaxZ; iz++) {
                for(let ix=iMinX; ix<=iMaxX; ix++) {
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (gridIdx < 0 || gridIdx >= state.gridMap.length) continue;
                    
                    const vertices = state.gridMap[gridIdx];
                    if (!vertices || vertices.length === 0) continue;

                    const wx = (ix * stepX) - w/2;
                    const wz = (iz * stepZ) - d/2;

                    let distSq;
                    if(l2===0) distSq = (wx-p1x)**2 + (wz-p1z)**2;
                    else {
                        let t = ((wx-p1x)*(p2x-p1x) + (wz-p1z)*(p2z-p1z)) / l2; t = Math.max(0, Math.min(1, t));
                        distSq = (wx-(p1x+t*(p2x-p1x)))**2 + (wz-(p1z+t*(p2z-p1z)))**2;
                    }

                    if(distSq < rSq) {
                        const firstV = vertices[0];
                        const currentWorldY = posAttr.getY(firstV) - stockH/2;

                        let targetWorldY = tipH;
                        if(isBall || (isDrill && distSq < rSq)) {
                            targetWorldY = tipH + (r - Math.sqrt(Math.max(0, rSq - distSq)));
                        }

                        if(currentWorldY > targetWorldY) {
                            const newLocalY = targetWorldY + stockH/2;
                            const depth = -targetWorldY; 
                            const dr = depth/stockH; 
                            const hue = 0.6 - dr*0.6; 
                            const c = new THREE.Color().setHSL(hue, 1.0, 0.5);

                            for(let k=0; k<vertices.length; k++) {
                                const vIdx = vertices[k];
                                posAttr.setY(vIdx, newLocalY);
                                colAttr.setXYZ(vIdx, c.r, c.g, c.b);
                            }
                        }
                    }
                }
            }
            posAttr.needsUpdate=true; colAttr.needsUpdate=true; 
        }

        function exportToTXT() {
            if (!state.stockMesh) return;
            let output = "X Y Z\n";
            const pos = state.stockMesh.geometry.attributes.position;
            
            const w = parseFloat(els.stockW.value);
            const d = parseFloat(els.stockD.value);
            const h = parseFloat(els.stockH.value);
            const segs = CONF.millRes;
            const stepX = w/segs;
            const stepZ = d/segs;
            
            state.gridMap.forEach((indices, gridIdx) => {
                if(indices.length > 0) {
                    // Get Grid indices from linear idx
                    const ix = gridIdx % (segs + 1);
                    const iz = (segs - Math.floor(gridIdx / (segs + 1)));
                    
                    const i = indices[0]; 
                    const ly = pos.getY(i);
                    const worldY = ly - h/2;
                    
                    // Reconstruct World Coords from Grid
                    const wx = (ix * stepX) - w/2;
                    const wz = (iz * stepZ) - d/2;
                    
                    output += `${wx.toFixed(3)} ${wz.toFixed(3)} ${worldY.toFixed(3)}\n`;
                }
            });

            const blob = new Blob([output], { type: 'text/plain' });
            const l = document.createElement('a');
            l.href = URL.createObjectURL(blob);
            l.download = 'cnc_cloud.txt';
            l.click();
        }

        function on3DClick(e) {
            const r=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
            raycaster.setFromCamera(mouse, camera);
            let min=Infinity, idx=-1;
            for(let i=0; i<state.segments.length; i++) { const d = raycaster.ray.distanceSqToSegment(state.segments[i].start, state.segments[i].end); if(d<min) { min=d; idx=i; } }
            if(idx!==-1 && min<5) selectSeg(idx);
        }
        function onEditorClick() {
            const l = els.input.value.substring(0, els.input.selectionStart).split('\n').length-1;
            const i = state.segments.findIndex(s => s.lineIdx === l); if(i!==-1) selectSeg(i, false);
        }
        function onSliderScrub(e) {
            state.isPlaying=false; updatePlayUI(); 
            const ratio = e.target.value/1000;
            const targetTime = ratio * state.totalSimTime;
            
            let foundIdx = 0;
            for(let i=0; i<state.segments.length; i++) {
                const s = state.segments[i];
                if (targetTime >= s.startTime && targetTime <= (s.startTime + s.duration)) {
                    foundIdx = i;
                    break;
                }
                if (targetTime > s.startTime + s.duration) foundIdx = i; 
            }
            
            const s = state.segments[foundIdx];
            if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            state.currentSegmentIdx = foundIdx;
            
            const segTime = targetTime - s.startTime;
            state.progress = segTime / (s.duration || 1);
            if(state.progress > 1) state.progress = 1;
            
            const pos = new THREE.Vector3().lerpVectors(s.start, s.end, state.progress); 
            toolMesh.position.copy(pos); updateDRO(pos);
            els.percent.innerText = `${Math.floor(ratio*100)}%`; els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            
            simulateToState(foundIdx); 
            if(s.type==='G1') deformStockSegment(s.start, pos, s.toolId);
            
            if(state.stockMesh) state.stockMesh.geometry.computeVertexNormals();
        }
        function selectSeg(i, scrollEditor=true) {
            if(i<0 || i>=state.segments.length) return; state.currentSegmentIdx=i; state.progress=0; state.isPlaying=false; updatePlayUI();
            const s = state.segments[i]; if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            toolMesh.position.copy(s.start); updateDRO(s.start);
            highlightSelection(s); if(scrollEditor) highlightLineInEditor(s.lineIdx);
            
            const ratio = s.startTime / (state.totalSimTime || 1);
            els.percent.innerText = `${Math.floor(ratio*100)}%`; els.slider.value=ratio*1000; els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            simulateToState(i);
            if(state.stockMesh) state.stockMesh.geometry.computeVertexNormals();
        }
        function highlightSelection(s) {
            const a = highlightMesh.geometry.attributes.position; a.setXYZ(0, s.start.x, s.start.y, s.start.z); a.setXYZ(1, s.end.x, s.end.y, s.end.z);
            a.needsUpdate=true; highlightMesh.visible=true; highlightSphere.position.copy(s.start); highlightSphere.visible=true;
        }
        function highlightLineInEditor(l) { els.input.scrollTop = (l*20) - (els.input.clientHeight/2); }
        function updatePlayUI() { if(state.isPlaying) { els.iconPlay.classList.add('hidden'); els.iconPause.classList.remove('hidden'); } else { els.iconPlay.classList.remove('hidden'); els.iconPause.classList.add('hidden'); } }

        els.btnPlay.addEventListener('click', () => { 
            if(state.segments.length>0) { 
                if(state.currentSegmentIdx>=state.segments.length-1 && state.progress>=0.99) { 
                    state.currentSegmentIdx=0; state.progress=0; restoreStock();
                } 
                state.isPlaying=!state.isPlaying; updatePlayUI(); 
            }
        });
        els.btnReset.addEventListener('click', resetSim); els.btnRender.addEventListener('click', processCode);
        els.btnUpdateStock.addEventListener('click', () => { updateEnvironment(); resetSim(); });
        els.chkInvertY.addEventListener('change', (e) => { state.invertY = e.target.checked; processCode(); });
        els.chkComp.addEventListener('change', (e) => { state.useComp = e.target.checked; processCode(); });
        el('file-upload').addEventListener('change', (e) => { const f=e.target.files[0]; if(!f)return; const r=new FileReader(); r.onload=(ev)=>{els.input.value=ev.target.result; updateLineNumbers(); processCode(); saveData();}; r.readAsText(f); });
        el('cam-iso').addEventListener('click', () => { camera.position.set(120, 150, 200); controls.target.set(50,0,-50); controls.update(); });
        el('cam-top').addEventListener('click', () => { camera.position.set(50, 250, -50); controls.target.set(50,0,-50); controls.update(); });
        
        el('btn-save-local').addEventListener('click', () => { saveData(); alert("Zapisano stan!"); });
        els.btnExportTXT.addEventListener('click', exportToTXT);
        
        els.btnExportSTL.addEventListener('click', () => { 
            const e = new STLExporter(); 
            if(state.stockMesh) state.stockMesh.geometry.computeVertexNormals();
            const r = e.parse(state.stockMesh); 
            const b = new Blob([r], {type:'text/plain'}); 
            const l = document.createElement('a'); 
            l.href = URL.createObjectURL(b); 
            l.download = 'cnc_solid.stl'; 
            l.click(); 
        });

        const sampleMill = `(MASTER SHOWCASE V2.1)\n(Stock: 100x100x20 | Baza: Srodek X0 Y0)\n\n(Ustawienia Wstepne)\nG90 G17 G54\nG0 Z50\n\n(--- OP 1: PLANOWANIE POWIERZCHNI [T1 GLOWICA] ---)\n(Zbieramy 1mm z gory aby wyrownac material)\nT1 M6\nS2000 M3\nG0 X-60 Y0\nG0 Z5\nG1 Z-1 F800\nG1 X60\nG0 Z50\n\n(--- OP 2: KIESZEN Z WYSPA [T2 FREZ 10] ---)\n(Frezowanie ksztaltu wybierajacego material)\nT2 M6\nS3000 M3\nG0 X-35 Y-35\nG0 Z5\nG1 Z-4 F1000\n\n(Obwiednia zewnetrzna)\nG1 X35\nG1 Y35\nG1 X-35\nG1 Y-35\n\n(Wyspa srodkowa - pozostawienie materialu)\nG0 Z5\nG0 X-20 Y-20\nG1 Z-4 F1000\nG1 X20\nG1 Y20\nG1 X-20\nG1 Y-20\nG0 Z50\n\n(--- OP 3: ROZETA OZD [T3 KULA 6] ---)\n(Precyzyjne luki G2/G3)\nT3 M6\nS4500 M3\nG0 X0 Y0\nG0 Z2\nG1 Z-2 F1200\n\n(Luki spiralne)\nG3 X20 Y0 I10 J0\nG2 X0 Y20 R20\nG3 X-20 Y0 I-10 J0\nG2 X0 Y-20 R20\nG0 Z50\n\n(--- OP 4: WIERCENIE OTWOROW [T4 WIERTLO] ---)\n(Cykl G83 - z wycofaniem wiora)\nT4 M6\nS1500 M3\nG0 Z20\n(Otwor 1)\nG0 X40 Y40\nG83 X40 Y40 Z-15 R2 Q4 F300\n(Otwor 2)\nG83 X-40 Y40 Z-15 R2 Q4\n(Otwor 3)\nG83 X-40 Y-40 Z-15 R2 Q4\n(Otwor 4)\nG83 X40 Y-40 Z-15 R2 Q4\nG80\nG0 Z50\n\n(--- OP 5: GWINTOWANIE [T5 GWINTOWNIK] ---)\n(Cykl G84 - obroty prawe/lewe)\nT5 M6\nS400 M3\n(Gwintowanie otworow)\nG0 X40 Y40\nG84 X40 Y40 Z-12 R5 F1.5 (Skok 1.5mm)\nG84 X-40 Y40 Z-12 R5\nG84 X-40 Y-40 Z-12 R5\nG84 X40 Y-40 Z-12 R5\nG80\nG0 Z50\n\n(Koniec)\nG0 X0 Y0\nM30`;
        init();
    </script>
</body>
</html>
