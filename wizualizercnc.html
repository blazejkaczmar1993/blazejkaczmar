<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNC Simulator: Advanced Mill - Wersja 3.7 PL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Global Styles for CNC theme */
        body { margin: 0; overflow: hidden; background-color: #0b0b0d; color: #e0e0e0; font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1f2937 0%, #000000 120%); }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .panel {
            pointer-events: auto;
            background: rgba(18, 18, 20, 0.96);
            border: 1px solid #333;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            backdrop-filter: blur(12px);
            display: flex; flex-direction: column;
        }

        /* Toolbar Buttons (New Glass/Glow Style - Centered Text Fix) */
        .btn-toolbar {
            width: 100px; height: 36px;
            @apply rounded text-[10px] font-bold tracking-wide transition uppercase flex items-center justify-center gap-2 text-center; /* Added text-center here */
            background: rgba(255,255,255,0.05); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            color: #bbb; 
            flex-shrink: 0; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        .btn-toolbar:hover {
            background: rgba(255,255,255,0.1); 
            color: #fff; 
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(100, 150, 255, 0.4); /* Subtle glow effect */
            transform: translateY(-1px);
        }
        .btn-toolbar:active { transform: translateY(0); }
        .btn-toolbar svg { width: 16px; height: 16px; opacity: 0.8; }
        .btn-toolbar:hover svg { opacity: 1; }
        
        .btn-toolbar.action-open:hover { box-shadow: 0 0 10px #3b82f6; }
        .btn-toolbar.action-save:hover { box-shadow: 0 0 10px #22c55e; }
        .btn-toolbar.action-txt:hover { box-shadow: 0 0 10px #6366f1; }
        .btn-toolbar.action-cam:hover { box-shadow: 0 0 10px #f59e0b; }
        .btn-toolbar.mode-active { border-color: #f59e0b; background: rgba(245, 158, 11, 0.2); color: #fcd34d; }

        .toolbar-sep { height: 24px; width: 1px; background: #333; margin: 0 4px; flex-shrink: 0; }

        /* Control Switches */
        .ctrl-row { display: flex; gap: 8px; margin-top: 8px; }
        .ctrl-group { flex: 1; display: flex; flex-direction: column; gap: 2px; }
        .ctrl-label { font-size: 9px; font-weight: 800; color: #555; text-transform: uppercase; letter-spacing: 0.05em; }
        
        /* Neon Style for Speed Switches */
        .switch-box { 
            display: flex; 
            background: #111; 
            border-radius: 6px; 
            padding: 2px; 
            border: 1px solid #333; 
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .btn-switch {
            flex: 1; 
            font-size: 10px; 
            font-weight: 900; 
            padding: 5px 0; 
            text-align: center; 
            color: #444; /* Dark gray when inactive */
            border-radius: 4px; 
            transition: all 0.2s; 
            text-transform: uppercase; 
            cursor: pointer;
        }
        .btn-switch:hover { 
            color: #60a5fa; /* Light blue on hover */
            background: rgba(37, 99, 235, 0.1); 
        }
        .btn-switch.active { 
            background: #2563eb; 
            color: white; 
            box-shadow: 
                0 0 5px #3b82f6, 
                0 0 10px #3b82f6, 
                0 0 15px #3b82f6; /* NEON EFFECT */
            border: 1px solid #3b82f6;
            transform: translateY(-1px);
        }
        .btn-switch.active:hover {
            box-shadow: 
                0 0 8px #3b82f6, 
                0 0 20px #3b82f6, 
                0 0 30px #3b82f6;
        }

        /* Details / Accordion */
        details > summary {
            list-style: none; cursor: pointer; padding: 8px;
            background-color: rgba(255, 255, 255, 0.03); border-bottom: 1px solid #333;
            font-size: 11px; font-weight: 700; color: #60a5fa; text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s;
        }
        details > summary:hover { background-color: rgba(255, 255, 255, 0.07); }
        details > summary::after { content: '‚ñ∂'; font-size: 10px; margin-left: 8px; transition: transform 0.2s; }
        details[open] > summary::after { content: '‚ñº'; transform: rotate(0); }
        .details-content { padding: 10px; max-height: 350px; overflow-y: auto; }

        /* Editor Styles */
        .editor-wrapper {
            position: relative; display: flex; height: 100%; background-color: #0d0d0d;
            font-family: 'JetBrains Mono', 'Consolas', monospace; font-size: 13px; line-height: 20px; overflow: hidden;
        }
        .line-numbers {
            min-width: 35px; background-color: #151515; color: #555; text-align: right; padding: 10px 6px 10px 0;
            border-right: 1px solid #333; user-select: none; overflow: hidden; white-space: pre-wrap;
        }
        textarea { 
            flex-grow: 1; background-color: transparent; color: #a5f3fc; border: none; outline: none; padding: 10px;
            resize: none; white-space: pre; overflow-wrap: normal; overflow-x: auto; overflow-y: scroll;
        }
        textarea::selection { background-color: #2563eb; color: white; }

        /* Input Styles */
        input[type=number], select, input[type=text] {
            background-color: #000 !important; color: #ffffff !important;
            border: 1px solid #444 !important; border-radius: 3px; padding: 2px 6px;
            font-family: monospace; font-weight: 500; width: 100%; font-size: 11px; transition: border-color 0.2s;
        }
        input[type=number]:focus, select:focus, input[type=text]:focus { outline: none; border-color: #3b82f6 !important; }
        
        table { width: 100%; border-collapse: collapse; font-size: 10px; }
        th { text-align: left; color: #9ca3af; font-weight: 700; padding: 4px; border-bottom: 1px solid #444; font-size: 9px; text-transform: uppercase; }
        td { padding: 2px; border-bottom: 1px solid #222; vertical-align: middle; }
        .del-btn { color: #ef4444; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .del-btn:hover { color: #fca5a5; }

        /* Checkbox Styles */
        label { color: #9ca3af !important; font-size: 10px !important; font-weight: 700 !important; text-transform: uppercase; letter-spacing: 0.05em; display: block; margin-bottom: 2px; }
        .chk-container { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .chk-box { width: 14px; height: 14px; border: 1px solid #555; border-radius: 3px; background: #1a1a1a; display: flex; align-items: center; justify-content: center; }
        input[type="checkbox"] { display: none; }
        input[type="checkbox"]:checked + .chk-box { background: #2563eb; border-color: #2563eb; }
        input[type="checkbox"]:checked + .chk-box::after { content: '‚úì'; font-size: 10px; color: white; }

        /* Scrollbar & Range */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0d0d0d; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        input[type=range] { -webkit-appearance: none; background: transparent; height: 20px; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #3b82f6; margin-top: -5px; border: 2px solid #ffffff; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        .heatmap-gradient { width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, #3b82f6, #10b981, #eab308, #ef4444); margin-top: 4px; }
        
        /* G-Code Legend/Help Styles */
        .gcode-row { display: flex; justify-content: space-between; padding: 2px 4px; border-bottom: 1px solid #222; font-family: monospace; font-size: 10px; color: #666; border-radius: 2px; transition: color 0.2s; }
        .gcode-key { color: #60a5fa; font-weight: bold; min-width: 30px; opacity: 0.7; }
        
        .gcode-row.active-code { background-color: rgba(16, 185, 129, 0.15); color: #e0e0e0; border-color: rgba(16, 185, 129, 0.3); }
        .gcode-row.active-code .gcode-key { color: #34d399; opacity: 1; }

        .legend-cat { 
            font-size: 9px; font-weight: 800; color: #9ca3af; text-transform: uppercase; 
            margin-top: 12px; margin-bottom: 4px; letter-spacing: 0.05em; border-bottom: 1px solid #333; padding-bottom: 2px;
        }

        /* Console/MDI Styles */
        #console-log {
            flex-grow: 1; 
            background: #000; 
            overflow-y: auto; 
            padding: 4px;
            font-family: monospace; 
            font-size: 10px;
        }
        .log-entry { padding: 1px 0; }
        .log-MDI { color: #60a5fa; } /* Blue for user input */
        .log-OK { color: #10b981; } /* Green for success */
        .log-ERR { color: #ef4444; font-weight: bold; } /* Red for errors */
        .log-WARN { color: #f59e0b; } /* Yellow for warnings */
        .log-INFO { color: #9ca3af; } /* Gray for general info */

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="p-3">
        
        <!-- Top Bar -->
        <div class="panel w-full flex items-center justify-between p-2 mb-3 h-16 flex-row gap-2">
            <div class="flex items-center gap-4 pl-2 min-w-[180px]">
                <div class="font-bold text-lg tracking-widest text-white flex items-center gap-2 select-none">
                    <span class="text-blue-500">CNC</span><span class="text-gray-400">VIZ</span>
                    <span class="bg-blue-900/50 text-blue-200 text-[10px] px-1.5 py-0.5 rounded border border-blue-800">V3.7</span>
                </div>
            </div>

            <div class="flex items-center gap-2 pr-2 overflow-x-auto flex-grow justify-end">
                <!-- Operation Mode Selector -->
                <button id="mode-auto" class="btn-toolbar action-txt mode-active" title="Tryb Automatyczny (DNC/Program)">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                    <span>AUTO</span>
                </button>
                <button id="mode-mdi" class="btn-toolbar action-txt" title="Tryb MDI (Manual Data Input) - pojedyncze komendy">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9h-3a2 2 0 00-2 2v5a2 2 0 002 2h3m-9 1l4-4M5 21l4-4M9 13l4-4"/></svg>
                    <span>MDI</span>
                </button>
                <div class="toolbar-sep"></div>

                <label class="btn-toolbar action-open cursor-pointer">
                    <input type="file" id="file-upload" accept=".nc,.gcode,.txt" class="hidden">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path></svg>
                    <span>OTW√ìRZ</span>
                </label>
                
                <button id="btn-export-stl" class="btn-toolbar action-save">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    <span>STL</span>
                </button>
                
                <button id="btn-export-txt" class="btn-toolbar action-txt">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    <span>TXT</span>
                </button>
                
                <div class="toolbar-sep"></div>
                
                <button id="cam-iso" class="btn-toolbar action-cam" title="Widok Izometryczny">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>
                    <span>ISO</span>
                </button>
                <button id="cam-top" class="btn-toolbar action-cam" title="Widok z G√≥ry">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 12a2 2 0 100-4 2 2 0 000 4z"></path></svg>
                    <span>TOP</span>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex flex-col md:flex-row gap-3 h-full overflow-hidden pb-3 relative">
            
            <!-- Left Sidebar -->
            <div class="flex flex-col gap-3 w-full md:w-80 lg:w-96 flex-shrink-0 order-2 md:order-1 max-h-[calc(100vh-90px)] overflow-hidden">
                
                <!-- Accordion Panel -->
                <div class="panel flex-shrink-0 overflow-hidden flex flex-col" style="max-height: 50%;">
                    
                    <!-- Tools Section -->
                    <details open class="border-b border-gray-800">
                        <summary>Mened≈ºer Narzƒôdzi</summary>
                        <div class="details-content bg-black/20">
                            <table class="mb-2">
                                <thead><tr><th width="5%"></th><th width="15%">T#</th><th width="35%">Typ</th><th width="20%">√ò</th><th width="25%">Ostrze</th></tr></thead>
                                <tbody id="tool-table-body"></tbody>
                            </table>
                            <button onclick="addNewTool()" class="w-full bg-gray-800 hover:bg-gray-700 text-[10px] text-blue-400 py-1 rounded border border-gray-700 border-dashed transition">+ DODAJ NARZƒòDZIE</button>
                        </div>
                    </details>

                    <!-- Stock Section -->
                    <details>
                        <summary>Przygot√≥wka (Stock)</summary>
                        <div class="details-content space-y-3">
                            <div class="grid grid-cols-3 gap-2">
                                <div><label>X (Szer)</label><input type="number" id="stock-w" value="100"></div>
                                <div><label>Y (D≈Çug)</label><input type="number" id="stock-d" value="100"></div>
                                <div><label>Z (Wys)</label><input type="number" id="stock-h" value="20"></div>
                            </div>
                            <div class="flex gap-3 items-center justify-between text-[10px]">
                                <label class="chk-container"><input type="checkbox" id="chk-invert-y"><span class="chk-box"></span><span>Lustro Y (ISO)</span></label>
                                <label class="chk-container"><input type="checkbox" id="chk-comp"><span class="chk-box"></span><span>Kompensacja (WIP)</span></label>
                            </div>
                            <button id="btn-update-stock" class="bg-blue-700 hover:bg-blue-600 text-[10px] font-bold text-white rounded py-1.5 w-full shadow transition">AKTUALIZUJ BRY≈Åƒò</button>
                        </div>
                    </details>

                    <!-- G-Code Info Section -->
                    <details>
                        <summary>Info G-Code (Legenda)</summary>
                        <div class="details-content">
                            <div id="gcode-legend" class="space-y-0">
                                <!-- Dynamic Content -->
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Code Editor / MDI Console -->
                <div class="panel flex-grow flex flex-col overflow-hidden border-t-2 border-blue-600 min-h-0">
                    <div class="p-1.5 bg-[#151515] border-b border-gray-800 flex justify-between items-center flex-shrink-0">
                        <span id="editor-title" class="text-[10px] font-bold text-gray-400 uppercase tracking-widest pl-2">Program NC</span>
                        <div class="flex gap-2">
                            <button id="btn-save-local" class="text-xs text-gray-500 hover:text-white transition" title="Zapisz stan do pamiƒôci przeglƒÖdarki">üíæ Auto-Save</button>
                            <button id="btn-render" class="bg-green-700 hover:bg-green-600 text-white text-[10px] font-bold py-0.5 px-2 rounded uppercase tracking-wide transition">Przelicz</button>
                        </div>
                    </div>
                    <div id="editor-auto-view" class="editor-wrapper flex-grow">
                        <div id="line-numbers" class="line-numbers">1</div>
                        <textarea id="gcode-input" spellcheck="false" placeholder="Wklej G-kod..."></textarea>
                    </div>

                    <!-- MDI Mode -->
                    <div id="editor-mdi-view" class="flex-col flex-grow hidden">
                        <div id="console-log">
                            <div class="log-entry log-INFO">CNC V3.6: Witam! Wprowad≈∫ komendƒô w MDI.</div>
                            <div class="log-entry log-INFO">Tryb: AUTO. Kliknij MDI aby aktywowaƒá wprowadzanie.</div>
                        </div>
                        <div class="flex p-2 gap-2 bg-[#151515] border-t border-gray-800">
                            <span class="text-yellow-500 font-mono text-sm">[MDI]</span>
                            <input type="text" id="mdi-input" placeholder="Wprowad≈∫ G-kod (np. G0 X10 Y10)..." class="flex-grow !bg-black !border-gray-600 !text-yellow-300 !font-mono !text-sm">
                        </div>
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="panel p-3 flex-shrink-0">
                    <div class="flex items-center justify-between mb-2 gap-3">
                        <button id="btn-play" class="w-8 h-8 flex-shrink-0 rounded-full bg-white text-black hover:bg-gray-200 flex items-center justify-center transition shadow-lg">
                            <svg id="icon-play" class="w-4 h-4 ml-0.5" fill="currentColor" viewBox="0 0 20 20"><path d="M4 4l12 6-12 6z"/></svg>
                            <svg id="icon-pause" class="w-4 h-4 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4h3v12H5V4zm7 0h3v12h-3V4z"/></svg>
                        </button>
                        <div class="flex flex-col flex-grow">
                            <div class="flex justify-between text-[10px] font-bold text-gray-400 mb-1 font-mono">
                                <span id="current-line-idx" class="text-blue-400">N: 0</span>
                                <span id="tool-display" class="text-yellow-400">T: -</span>
                                <span id="progress-percent" class="text-green-400">0%</span>
                            </div>
                            <input type="range" id="progress-slider" min="0" max="1000" value="0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            
                            <!-- CONTROL ROW: SPEED ONLY -->
                            <div class="ctrl-row">
                                <div class="ctrl-group">
                                    <span class="ctrl-label">Prƒôdko≈õƒá symulacji</span>
                                    <div class="switch-box">
                                        <div class="btn-switch active speed" data-speed="5" onclick="setSpeed(5, this)">1x (REAL)</div>
                                        <div class="btn-switch speed" data-speed="25" onclick="setSpeed(25, this)">5x</div>
                                        <div class="btn-switch speed" data-speed="125" onclick="setSpeed(125, this)">25x</div>
                                        <div class="btn-switch speed" data-speed="500" onclick="setSpeed(500, this)">100x</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="btn-reset" class="p-1.5 text-gray-500 hover:text-white transition" title="Resetuj program i materia≈Ç"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg></button>
                    </div>
                </div>
            </div>

            <!-- Right DRO & Stats -->
            <div class="absolute right-4 top-4 pointer-events-none flex flex-col gap-2 items-end">
                <div class="panel p-4 pointer-events-auto min-w-[200px]">
                    <!-- DRO READOUTS -->
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2 border-b border-gray-700 pb-1">POZYCJA WSP√ì≈ÅRZƒòDNE (DRO)</div>
                    <div class="font-mono text-lg grid grid-cols-[20px_1fr] gap-y-1">
                        <span class="text-red-500 font-bold">X</span><span id="pos-x" class="text-right text-white font-bold tracking-wider">0.000</span>
                        <span class="text-green-500 font-bold">Y</span><span id="pos-y" class="text-right text-white font-bold tracking-wider">0.000</span>
                        <span class="text-blue-500 font-bold">Z</span><span id="pos-z" class="text-right text-white font-bold tracking-wider">0.000</span>
                    </div>
                    <!-- Status Indicators (Dynamic Content Only) -->
                    <div class="mt-3 pt-2 border-t border-gray-800 text-[10px] font-mono space-y-1">
                         <span id="status-mode" class="text-yellow-400 font-bold block">G90 ABSOLUTNY</span>
                         <span id="status-retract" class="text-indigo-400 font-bold block">G98 Wycofanie: START</span>
                         <span id="status-feed-mode" class="text-purple-400 font-bold block">G94 Posuw: MINUTOWY</span>
                         <span id="status-plane" class="text-blue-400 font-bold block">G17 P≈Çaszczyzna: XY</span>
                         <span id="status-comp" class="text-pink-400 font-bold block">G40 Kompensacja: OFF</span>
                         <span id="status-feed" class="text-green-400 font-bold block">F 500</span>
                         <span id="status-rpm" class="text-red-400 font-bold block">S 1000</span>
                    </div>

                    <div id="collision-alert" class="hidden mt-2 text-center bg-red-900/90 border border-red-600 text-white text-[10px] font-bold py-2 px-2 rounded animate-pulse shadow-[0_0_15px_rgba(255,0,0,0.5)]">
                        ‚ö†Ô∏è KOLIZJA ‚ö†Ô∏è<br><span id="collision-msg">OPRAWKA</span>
                    </div>
                </div>
                
                <div class="panel p-3 pointer-events-auto min-w-[200px]">
                    <div class="text-[10px] font-bold text-gray-500 tracking-widest mb-2">G≈ÅƒòBOKO≈öƒÜ SKRAWANIA</div>
                    <div class="heatmap-gradient"></div>
                    <div class="flex justify-between text-[9px] text-gray-400 mt-1 font-mono">
                        <span>0 (G√ìRA)</span>
                        <span>MAX</span>
                    </div>
                </div>

                <div class="panel p-3 pointer-events-auto text-[10px] text-gray-400 px-4 flex flex-col items-end gap-1">
                   <span class="font-bold border-b border-gray-700 pb-1 mb-1 block w-full text-right">ZAKRESY NARZƒòDZIA</span>
                   <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-right">
                        <span>X min/max:</span><span id="range-x" class="text-white font-mono">-</span>
                        <span>Y min/max:</span><span id="range-y" class="text-white font-mono">-</span>
                        <span>Z min/max:</span><span id="range-z" class="text-white font-mono">-</span>
                   </div>
                   <span class="mt-2 pt-2 border-t border-gray-800 w-full text-right text-green-400 font-bold">Czas: <span id="est-time" class="text-white font-mono">00:00:00</span></span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- KONFIGURACJA STA≈ÅA ---
        const CONF = {
            colorStockTop: 0xcccccc, // Jasny kolor wierzchni materia≈Çu
            colorStockSide: 0x888888, // Kolor boczny materia≈Çu
            millRes: 256, // Rozdzielczo≈õƒá siatki materia≈Çu (np. 256x256)
            rapidSpeed: 15000, // Szybko≈õƒá G0 (mm/min)
            defaultFeed: 500, // Domy≈õlny posuw G1
            toolChangePos: { x:0, y:0, z:50 }, // Pozycja wymiany narzƒôdzia w przestrzeni World (mm)
            units: 'MM', // Jednostki
            maxLogLines: 100 // Maksymalna ilo≈õƒá linii w konsoli
        };

        const STORAGE_KEY = 'cnc_viz_data_v3_2';

        // --- BAZA DANYCH NARZƒòDZI (Zmienna) ---
        let toolsDB = [
            { id: 1, type: 'FLAT', dia: 40, len: 50, shankDia: 20 }, // G≈Çowica
            { id: 2, type: 'FLAT', dia: 10, len: 30, shankDia: 10 }, // Frez P≈Çaski
            { id: 3, type: 'BALL', dia: 6, len: 20, shankDia: 6 },  // Frez Kulowy
            { id: 4, type: 'DRILL', dia: 5, len: 40, shankDia: 5 }, // Wiert≈Ço
            { id: 5, type: 'TAP', dia: 6, len: 35, shankDia: 6 }    // Gwintownik
        ];

        // --- OPISY G-KOD√ìW ---
        const G_DESC = {
            'G0': 'Ruch Szybki (Rapid) - Pozycjonowanie', 'G1': 'Ruch Roboczy (Linear) - Skrawanie',
            'G2': '≈Åuk Zgodnie z Zegarem (CW)', 'G3': '≈Åuk Przeciwnie do Zegara (CCW)',
            'G17': 'Wyb√≥r P≈Çaszczyzny XY', 'G18': 'Wyb√≥r P≈Çaszczyzny XZ', 'G19': 'Wyb√≥r P≈Çaszczyzny YZ',
            'G40': 'Anulowanie Kompensacji Promienia', 'G41': 'Kompensacja Promienia: Lewa', 'G42': 'Kompensacja Promienia: Prawa',
            'G43': 'Kompensacja D≈Çugo≈õci Narzƒôdzia (+H)', 'G49': 'Anulowanie Kompensacji D≈Çugo≈õci',
            'G54': 'Uk≈Çad Wsp√≥≈Çrzƒôdnych Roboczych 1', 'G80': 'Anulowanie Cykli Wiercenia',
            'G81': 'Cykl Wiercenia (Nawiercanie)', 'G83': 'Cykl Wiercenia G≈Çƒôbokiego (Peck)',
            'G84': 'Cykl Gwintowania (Tapping)', 
            'G90': 'Tryb Absolutny (Wzglƒôdem Zera)', 'G91': 'Tryb Przyrostowy (Wzglƒôdem Narzƒôdzia)',
            'G94': 'Posuw: Minutowy (mm/min)', 'G95': 'Posuw: Na Obrot (mm/rev)',
            'G98': 'Wycofanie po Cyklu: Do PoczƒÖtkowej Z', 'G99': 'Wycofanie po Cyklu: Do P≈Çaszczyzny R',
            'M3': 'Obroty Wrzeciona: Prawe (CW)', 'M4': 'Obroty Wrzeciona: Lewe (CCW)', 'M5': 'Stop Wrzeciona',
            'M6': 'Automatyczna Wymiana Narzƒôdzia', 'M8': 'Ch≈Çodziwo: W≈ÇƒÖcz (Flood)', 'M9': 'Ch≈Çodziwo: Wy≈ÇƒÖcz',
            'M30': 'Koniec Programu (Rewind)', 'T': 'Wyb√≥r Narzƒôdzia (Tool)', 'F': 'Posuw (Feed Rate)',
            'S': 'Obroty (Spindle Speed RPM)', 'H': 'Kompensacja D≈Çugo≈õci (Offset)', 'D': 'Kompensacja Promienia (Offset)'
        };

        const G_CATS = {
            "Ruch i Interpolacja": ['G0', 'G1', 'G2', 'G3'],
            "Cykle Wiercenia": ['G80', 'G81', 'G83', 'G84', 'G98', 'G99'],
            "Ustawienia Wymiary": ['G90', 'G91', 'G54'],
            "Posuw i Wrzeciono": ['G94', 'G95', 'F', 'S'],
            "Kompensacje i P≈Çaszczyzny": ['G17', 'G18', 'G19', 'G40', 'G41', 'G42', 'G43', 'G49'],
            "Funkcje Maszynowe (M)": ['M3', 'M4', 'M5', 'M6', 'M8', 'M9', 'M30'],
            "Parametry": ['T', 'H', 'D']
        };

        // --- STAN SYMULATORA ---
        const state = {
            // Symulacja
            isPlaying: false, speed: 5, progress: 0, currentSegmentIdx: 0, // Domy≈õlna prƒôdko≈õƒá: 5x
            segments: [], totalSimTime: 0, simulatedHeadIdx: 0,
            bounds: { min: new THREE.Vector3(), max: new THREE.Vector3() },
            // Maszyna
            activeToolId: 1, stockMesh: null, gridMap: null,
            stockDims: { w: 100, d: 100, h: 20, stepX: 1, stepZ: 1, segs: CONF.millRes },
            // Sterownik
            mode: 'AUTO', // 'AUTO', 'MDI'
            modalG: { move: 'G0', comp: 'G40', dist: 'G90', plane: 'G17', feed: 'G94', retract: 'G98' }, // Domy≈õlnie G94, G98
            modalM: { spindle: 'M5', cool: 'M9' },
            curFeed: CONF.defaultFeed, curRPM: 1000,
            curPos: new THREE.Vector3(0, CONF.toolChangePos.z, 0), // World X, Y, Z
            // UI Flags
            invertY: false, useComp: false
        };

        let scene, camera, renderer, controls, clock, transformControls;
        let toolMesh, toolShank, highlightMesh, highlightSphere;
        let pathGroup = new THREE.Group();
        let helpersGroup = new THREE.Group();
        let raycaster, mouse, chipSystem;
        let frameCount = 0;
        
        const el = (id) => document.getElementById(id);
        const els = {
            // UI elements
            input: el('gcode-input'), lineNums: el('line-numbers'),
            btnRender: el('btn-render'), btnPlay: el('btn-play'), btnReset: el('btn-reset'), 
            btnExportSTL: el('btn-export-stl'), btnExportTXT: el('btn-export-txt'),
            slider: el('progress-slider'), btnUpdateStock: el('btn-update-stock'),
            chkInvertY: el('chk-invert-y'), chkComp: el('chk-comp'),
            stockW: el('stock-w'), stockD: el('stock-d'), stockH: el('stock-h'), 
            toolTableBody: el('tool-table-body'), gcodeLegend: el('gcode-legend'),
            posX: el('pos-x'), posY: el('pos-y'), posZ: el('pos-z'), 
            collisionAlert: el('collision-alert'), collisionMsg: el('collision-msg'),
            rangeX: el('range-x'), rangeY: el('range-y'), rangeZ: el('range-z'),
            lineIdx: el('current-line-idx'), percent: el('progress-percent'), estTime: el('est-time'), toolDisplay: el('tool-display'),
            iconPlay: el('icon-play'), iconPause: el('icon-pause'),
            // Console/MDI
            mdiInput: el('mdi-input'), consoleLog: el('console-log'),
            modeAutoBtn: el('mode-auto'), modeMdiBtn: el('mode-mdi'),
            editorAutoView: el('editor-auto-view'), editorMdiView: el('editor-mdi-view'),
            editorTitle: el('editor-title'),
            // DRO Status
            statusMode: el('status-mode'), statusRetract: el('status-retract'), statusFeedMode: el('status-feed-mode'), statusPlane: el('status-plane'), statusComp: el('status-comp'),
            statusFeed: el('status-feed'), statusRpm: el('status-rpm')
        };

        // --- CONTROLS Functions ---
        window.setSpeed = (val, elem) => {
            state.speed = val;
            document.querySelectorAll('.btn-switch.speed').forEach(b => b.classList.remove('active'));
            elem.classList.add('active');
        };

        // --- Logger (Konsola) ---
        function log(message, type = 'INFO') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerText = `[${type}] ${message}`;
            els.consoleLog.appendChild(entry);
            
            // Limit log lines
            while (els.consoleLog.children.length > CONF.maxLogLines) {
                els.consoleLog.removeChild(els.consoleLog.firstChild);
            }
            els.consoleLog.scrollTop = els.consoleLog.scrollHeight;
        }

        // --- UI MODE (AUTO/MDI) ---
        function setUIMode(mode) {
            state.mode = mode;
            els.modeAutoBtn.classList.toggle('mode-active', mode === 'AUTO');
            els.modeMdiBtn.classList.toggle('mode-active', mode === 'MDI');
            
            els.editorAutoView.classList.toggle('hidden', mode === 'MDI');
            els.editorMdiView.classList.toggle('hidden', mode === 'AUTO');
            
            els.btnRender.disabled = mode === 'MDI';
            els.btnPlay.disabled = mode === 'MDI';
            els.slider.disabled = mode === 'MDI';

            els.editorTitle.innerText = mode === 'AUTO' ? 'Program NC' : 'MDI / KONSOLA';
            
            if (mode === 'MDI') {
                transformControls.attach(toolMesh);
                transformControls.enabled = true;
                controls.enabled = false;
                log("Tryb MDI aktywny. Mo≈ºesz rƒôcznie przesuwaƒá o≈õ lub wpisywaƒá G-kod.", "WARN");
            } else {
                if (transformControls.object) transformControls.detach();
                transformControls.enabled = false;
                controls.enabled = true;
                // W trybie AUTO narzƒôdzie jest kontrolowane przez symulacjƒô
                log("Tryb AUTO aktywny. Narzƒôdzie kontrolowane przez Program NC.", "INFO");
            }
        }

        // --- Persistence ---
        function loadData() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (data.tools) toolsDB = data.tools;
                    if (data.code) els.input.value = data.code;
                    if (data.dims) {
                        els.stockW.value = data.dims.w;
                        els.stockD.value = data.dims.d;
                        els.stockH.value = data.dims.h;
                    }
                }
            } catch (e) { log(`B≈ÇƒÖd ≈Çadowania danych lokalnych: ${e.message}`, "ERR"); }
        }

        function saveData() {
            const data = {
                tools: toolsDB,
                code: els.input.value,
                dims: { w: els.stockW.value, d: els.stockD.value, h: els.stockH.value }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        // --- UI Tool Functions (window exposure for inline handlers) ---
        function renderToolTable() {
            const tbody = els.toolTableBody; tbody.innerHTML = '';
            toolsDB.forEach((t, idx) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="text-center"><span class="del-btn" onclick="removeTool(${idx})">√ó</span></td>
                    <td><input type="number" value="${t.id}" onchange="editTool(${idx}, 'id', this.value)" style="width:40px; text-align:center;"></td>
                    <td><select onchange="editTool(${idx}, 'type', this.value)" class="bg-transparent border-none h-5 text-[10px]">
                        <option value="FLAT" ${t.type==='FLAT'?'selected':''}>Frez P≈Çaski</option>
                        <option value="BALL" ${t.type==='BALL'?'selected':''}>Frez Kulowy</option>
                        <option value="DRILL" ${t.type==='DRILL'?'selected':''}>Wiert≈Ço</option>
                        <option value="TAP" ${t.type==='TAP'?'selected':''}>Gwintownik</option>
                    </select></td>
                    <td><input type="number" value="${t.dia}" onchange="editTool(${idx}, 'dia', this.value)" class="h-5 text-[10px]"></td>
                    <td><input type="number" value="${t.len}" onchange="editTool(${idx}, 'len', this.value)" class="h-5 text-[10px]"></td>
                `;
                tbody.appendChild(tr);
            });
            saveData();
        }
        window.editTool = (arrIdx, key, val) => {
            const t = toolsDB[arrIdx];
            if(key==='type') t.type=val; else t[key]=parseFloat(val);
            if(t.id === state.activeToolId) updateToolMesh(t.id);
            saveData();
        };
        window.removeTool = (arrIdx) => {
            toolsDB.splice(arrIdx, 1); renderToolTable(); saveData();
        };
        window.addNewTool = () => {
            const newId = toolsDB.length > 0 ? Math.max(...toolsDB.map(t=>t.id)) + 1 : 1;
            toolsDB.push({ id: newId, type: 'FLAT', dia: 10, len: 30, shankDia: 10 });
            renderToolTable();
        };
        window.renderToolTable = renderToolTable; // Expose for initial call

        // --- G-CODE HELPER FUNCTIONS ---
        function updateBounds(v) { 
            state.bounds.min.min(v); 
            state.bounds.max.max(v); 
        }

        function updateLineNumbers() {
            const lines = els.input.value.split('\n').length;
            els.lineNums.innerHTML = Array(lines).fill(0).map((_, i) => i + 1).join('<br>');
        }

        // --- THREE.JS INITIALIZATION ---
        function init() {
            loadData();

            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x1a1a20, 0.001);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(120, 150, 200);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            el('canvas-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor=0.05;
            
            clock = new THREE.Clock(); 

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(50, 200, 100); dl.castShadow=true; 
            dl.shadow.mapSize.width=2048; dl.shadow.mapSize.height=2048; scene.add(dl);
            
            // Controls (Gizmo for MDI mode)
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.setSize(0.5); // Smaller handles
            transformControls.setMode('translate');
            transformControls.showRotation = false;
            transformControls.showScale = false;
            transformControls.setTranslationSnap(0.01); // Snap to 0.01mm
            scene.add(transformControls);

            // Path and Helpers
            scene.add(pathGroup); scene.add(helpersGroup);
            
            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 3.0; 
            mouse = new THREE.Vector2();

            chipSystem = new ChipSystem(scene);
            
            // Highlight for selection/current segment
            const hg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            highlightMesh = new THREE.Line(hg, new THREE.LineBasicMaterial({color:0xff00ff, linewidth:5, depthTest:false}));
            highlightMesh.renderOrder=999; highlightMesh.visible=false; scene.add(highlightMesh);
            highlightSphere = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color:0xff00ff, depthTest:false}));
            highlightSphere.renderOrder=999; highlightSphere.visible=false; scene.add(highlightSphere);

            // Initial UI setup
            renderToolTable();
            updateToolMesh(1); 
            updateEnvironment();
            setUIMode('AUTO'); // Start in AUTO mode
            
            if (!els.input.value) els.input.value = sampleMill;
            updateLineNumbers(); 
            processCode(); // Initial parse
            
            // Event Listeners
            window.addEventListener('resize', onResize);
            el('canvas-container').addEventListener('mousedown', on3DClick);
            els.input.addEventListener('click', onEditorClick);
            els.input.addEventListener('keyup', onEditorClick);
            els.input.addEventListener('input', () => { updateLineNumbers(); saveData(); });
            els.input.addEventListener('scroll', () => { els.lineNums.scrollTop = els.input.scrollTop; });
            els.slider.addEventListener('input', onSliderScrub);

            // MDI Events
            els.mdiInput.addEventListener('keypress', onMDIEnter);

            // Gizmo Events
            transformControls.addEventListener('dragging-changed', function(event) { controls.enabled = !event.value; });
            transformControls.addEventListener('objectChange', onGizmoMove);

            animate();
        }
        
        // --- EVENT HANDLERS ---
        function onResize() { 
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }

        // Handle tool movement via MDI Gizmo
        function onGizmoMove() {
            const newPos = toolMesh.position.clone();
            const startPos = state.curPos.clone();
            
            // Simple G0 move for MDI
            const seg = {
                start: startPos, 
                end: newPos, 
                type: 'G0', 
                lineIdx: -1, // MDI lines have no index
                feed: CONF.rapidSpeed, 
                toolId: state.activeToolId
            };

            // This only updates state.curPos for DRO, does not add to path segments.
            state.curPos = newPos.clone();
            updateDRO(newPos);
        }

        function onMDIEnter(e) {
            if (e.key === 'Enter') {
                const command = els.mdiInput.value.trim().toUpperCase();
                els.mdiInput.value = '';
                if (!command) return;

                log(command, 'MDI');
                executeMDICommand(command);
            }
        }
        
        // --- TOOL MESH (Wizualizacja narzƒôdzia) ---
        function updateToolMesh(id) {
            state.activeToolId = id;
            const t = toolsDB.find(x => x.id == id) || toolsDB[0];
            if(!t) { log(`Narzƒôdzie T${id} nie znalezione. U≈ºywam T1.`, "WARN"); updateToolMesh(toolsDB[0].id); return; }
            
            const r = t.dia / 2;
            const fluteLen = t.len;
            const shankR = (t.shankDia || t.dia) / 2;
            
            els.toolDisplay.innerText = `T${id}: ${t.type} √ò${t.dia} / L${t.len}`;
            
            if(toolMesh) scene.remove(toolMesh);
            toolMesh = new THREE.Group();
            
            let flutes;
            
            if (t.type === 'BALL') {
                const tipGeo = new THREE.SphereGeometry(r, 32, 16); tipGeo.translate(0, r, 0);
                const cylLen = Math.max(0, fluteLen - r);
                const cylGeo = new THREE.CylinderGeometry(r, r, cylLen, 32);
                cylGeo.translate(0, r + cylLen/2, 0);
                flutes = new THREE.Group();
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
                if (cylLen > 0.1) flutes.add(new THREE.Mesh(cylGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3 })));
            } else if (t.type === 'DRILL' || t.type === 'TAP') {
                const tipAngle = 118; // Typical drill tip angle
                const tipRad = (180 - tipAngle) / 2 * Math.PI / 180;
                const tipH = r / Math.tan(tipRad);
                const tipGeo = new THREE.ConeGeometry(r, tipH, 32);
                tipGeo.rotateX(Math.PI); tipGeo.translate(0, tipH/2, 0);
                const bodyLen = fluteLen - tipH;
                const bodyGeo = new THREE.CylinderGeometry(r, r, bodyLen, 32);
                bodyGeo.translate(0, tipH + bodyLen/2, 0);
                flutes = new THREE.Group();
                const color = t.type === 'TAP' ? 0x88ccff : 0xFFD700; // Blueish for Tap
                flutes.add(new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: color })));
                flutes.add(new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color: color })));
            } else { // FLAT
                const tipGeo = new THREE.CylinderGeometry(r, r, fluteLen, 32);
                tipGeo.translate(0, fluteLen/2, 0);
                flutes = new THREE.Mesh(tipGeo, new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 }));
            }
            
            flutes.castShadow = true; 
            
            const shankLen = 40;
            const shankGeo = new THREE.CylinderGeometry(shankR, shankR, shankLen, 32);
            shankGeo.translate(0, fluteLen + shankLen/2, 0);
            toolShank = new THREE.Mesh(shankGeo, new THREE.MeshStandardMaterial({ color: 0xAAAAAA }));
            toolShank.castShadow = true;

            toolMesh.add(flutes); toolMesh.add(toolShank); scene.add(toolMesh);
            
            // Align tool mesh to current position after creation
            toolMesh.position.copy(state.curPos);
            
            // If in MDI mode, reattach gizmo
            if (state.mode === 'MDI') transformControls.attach(toolMesh);
        }

        // --- ENVIRONMENT & STOCK MESH ---
        function updateEnvironment() {
            helpersGroup.clear();
            helpersGroup.add(new THREE.GridHelper(300, 30, 0x555555, 0x222222));
            helpersGroup.add(new THREE.AxesHelper(30));
            const lbl = (t,c,p) => {
                const cv=document.createElement('canvas'); cv.width=64; cv.height=64;
                const x=cv.getContext('2d'); x.fillStyle=c; x.font="bold 48px Arial"; x.fillText(t,32,48);
                const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv), transparent:true, depthTest:false}));
                s.position.copy(p); s.scale.set(8,8,1); helpersGroup.add(s);
            };
            // X (Red), Z (Blue, up), Y (Green, away from camera)
            lbl("X", "#f44", new THREE.Vector3(35,0,0)); 
            lbl("Z", "#44f", new THREE.Vector3(0,35,0)); 
            lbl("Y", "#4f4", new THREE.Vector3(0,0,-35));
            
            const h = parseFloat(els.stockH.value)||20;
            
            // Floor/Table
            const grid = new THREE.GridHelper(300, 30, 0x444444, 0x222222);
            grid.position.y = -h; // Grid at bottom of stock
            helpersGroup.add(grid);

            const table = new THREE.Mesh(new THREE.BoxGeometry(300, 2, 300), new THREE.MeshStandardMaterial({color:0x111111}));
            table.position.y = -h - 1; 
            table.receiveShadow = true; 
            helpersGroup.add(table);

            createStockMesh();
        }

        function createStockMesh() {
            if (state.stockMesh) { scene.remove(state.stockMesh); if(state.stockMesh.geometry) state.stockMesh.geometry.dispose(); }
            
            const w = parseFloat(els.stockW.value)||100; 
            const d = parseFloat(els.stockD.value)||100; 
            const h = parseFloat(els.stockH.value)||20;
            
            const segs = CONF.millRes;
            // Create BoxGeometry with many segments in X and Z, but only 1 in Y (Height)
            const geo = new THREE.BoxGeometry(w, h, d, segs, 1, segs);
            
            const count = geo.attributes.position.count;
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*3), 3));
            const col = geo.attributes.color;
            const pos = geo.attributes.position;
            
            const topColor = new THREE.Color(CONF.colorStockTop);
            const sideColor = new THREE.Color(CONF.colorStockSide);
            
            // Initialize Grid Map (to link top surface vertices to grid indices)
            state.gridMap = new Array((segs + 1) * (segs + 1)).fill(null).map(() => []);
            const stepX = w / segs;
            const stepZ = d / segs;
            
            state.stockDims = { w, d, h, stepX, stepZ, segs };

            const epsilon = 0.01;

            for(let i=0; i<count; i++) {
                const y = pos.getY(i);
                // Box is h tall, centered at local 0. Top face vertices are at local Y=h/2.
                if (y > (h/2 - epsilon)) {
                    col.setXYZ(i, topColor.r, topColor.g, topColor.b);
                    
                    // Map vertex to grid index (X: -w/2 to w/2 -> 0 to segs)
                    const x = pos.getX(i) + w/2;
                    const z = pos.getZ(i) + d/2;
                    
                    const ix = Math.round(x / stepX);
                    const iz = Math.round(z / stepZ);
                    
                    // Grid index: (segs - iz) to get z-index 0 at +d/2 (front), and +d/2 at 0
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (state.gridMap[gridIdx]) state.gridMap[gridIdx].push(i);
                } else {
                    col.setXYZ(i, sideColor.r, sideColor.g, sideColor.b);
                }
            }

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.5, metalness: 0.3, flatShading: false });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Center the mesh so Top is at World Y=0. Local top is h/2. Shift by -h/2.
            mesh.position.set(0, -h/2, 0);
            
            mesh.castShadow = true; mesh.receiveShadow = true;
            state.stockMesh = mesh;
            scene.add(mesh);
            
            state.simulatedHeadIdx = 0;
            saveData();
        }

        // --- COORDINATE SYSTEM HELPERS ---
        // Converts CNC logic coordinates (X, Y, Z) to Three.js World coordinates (X, Z, Y)
        function mapCoords(c) {
            // CNC X -> World X
            // CNC Y -> World Z (Inverted or not, depending on convention)
            // CNC Z -> World Y (Height)
            const yFact = state.invertY ? 1 : -1; // Standard CNC (Y forward) vs 3D (Z forward)
            return new THREE.Vector3(c.x, c.z, c.y * yFact); 
        }

        // Converts Three.js World coordinates (X, Y, Z) back to CNC logic (X, Y, Z)
        function unmapCoords(v) {
             const yFact = state.invertY ? 1 : -1;
             return { x: v.x, y: v.z / yFact, z: v.y };
        }
        
        // Gets the current height of the material at a world XZ coordinate
        function getMaterialHeightAt(wx, wz) {
            if (!state.stockMesh || !state.gridMap) return -999; 
            
            const { w, d, h, stepX, stepZ, segs } = state.stockDims;

            // Convert World XZ to local grid coordinates
            const gridWX = wx + w/2;
            const gridWZ = wz + d/2;

            if (gridWX < 0 || gridWX > w || gridWZ < 0 || gridWZ > d) return -999; 

            // Calculate grid index (nearest point)
            const ix = Math.round(gridWX / stepX);
            const iz = Math.round(gridWZ / stepZ);

            if (ix < 0 || ix > segs || iz < 0 || iz > segs) return -999;

            // Z is inverted in mapping process: segs - iz
            const gridIdx = (segs - iz) * (segs + 1) + ix; 
            if (gridIdx < 0 || gridIdx >= state.gridMap.length) return -999;

            const vertices = state.gridMap[gridIdx];
            if (!vertices || vertices.length === 0) return -999;

            const posAttr = state.stockMesh.geometry.attributes.position;
            const localY = posAttr.getY(vertices[0]); // Local Y is h/2 (top) to -h/2 (bottom)
            
            // Convert local Y to World Y (World Top is 0)
            return localY - (h/2); 
        }

        // --- CHIP PARTICLE SYSTEM ---
        class ChipSystem {
            constructor(scene) {
                this.max = 3000; this.idx = 0;
                this.geo = new THREE.BufferGeometry();
                this.pos = new Float32Array(this.max*3); this.vel = new Float32Array(this.max*3); this.life = new Float32Array(this.max);
                this.geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.mesh = new THREE.Points(this.geo, new THREE.PointsMaterial({color: 0xffd700, size: 0.6, transparent: true, opacity:0.8, depthWrite: false}));
                this.mesh.frustumCulled = false; scene.add(this.mesh);
            }
            emit(p, vol) {
                const cnt = Math.min(Math.floor(vol*5), 40);
                for(let i=0; i<cnt; i++) {
                    const k = this.idx;
                    // Initial position slightly random near the tool
                    this.pos[k*3] = p.x+(Math.random()-0.5)*1; 
                    this.pos[k*3+1] = p.y+Math.random()*1; 
                    this.pos[k*3+2] = p.z+(Math.random()-0.5)*1;
                    // Initial velocity
                    this.vel[k*3] = (Math.random()-0.5)*3; 
                    this.vel[k*3+1] = Math.random()*3+2; // Upwards velocity
                    this.vel[k*3+2] = (Math.random()-0.5)*3;
                    this.life[k] = 1.0;
                    this.idx = (this.idx+1) % this.max;
                }
            }
            update() {
                const dt = 1/60; // Assuming 60fps
                for(let i=0; i<this.max; i++) {
                    if(this.life[i]>0) {
                        this.vel[i*3+1] -= 9.8 * dt * 0.5; // Gravity effect
                        this.pos[i*3] += this.vel[i*3] * dt; 
                        this.pos[i*3+1] += this.vel[i*3+1] * dt; 
                        this.pos[i*3+2] += this.vel[i*3+2] * dt;
                        
                        // Bounce off the table (World Y = -stockH)
                        const stockH = parseFloat(els.stockH.value)||20;
                        if(this.pos[i*3+1] < -stockH/2) { 
                            this.pos[i*3+1] = -stockH/2; 
                            this.vel[i*3+1] *= -0.5; // Bounce up
                            this.vel[i*3] *= 0.8; 
                            this.vel[i*3+2] *= 0.8; 
                        }
                        this.life[i] -= 0.03; // Fade out
                    } else { 
                        this.pos[i*3+1] = -999; // Move dead particles far away
                    }
                }
                this.geo.attributes.position.needsUpdate = true;
                this.mesh.material.opacity = 1;
            }
        }
        
        // --- ARC (G2/G3) LOGIC ---
        // Helper: Converts R radius to I/J offsets, handling positive/negative R
        function convertRtoIJ(x1, y1, x2, y2, r, isCw) {
            const d2 = (x2-x1)**2 + (y2-y1)**2;
            const d = Math.sqrt(d2);
            if (d < 0.0001) return {i:0, j:0};
            if (d > 2*Math.abs(r)) { 
                log(`R:${r} jest za ma≈Çe dla odleg≈Ço≈õci ${d.toFixed(2)}. U≈ºywam d/2.`, 'WARN');
                r = d/2;
            }
            const h = Math.sqrt(Math.max(0, r*r - d2/4));
            const dx = x2 - x1;
            const dy = y2 - y1;
            const xMid = (x1 + x2) / 2;
            const yMid = (y1 + y2) / 2;
            
            let side = isCw ? 1 : -1; 
            if (r < 0) { side = -side; r = Math.abs(r); } 
            
            // Calculate center point (cx, cy)
            const cx = xMid + side * (dy * h / d);
            const cy = yMid + side * (-dx * h / d);
            
            return { i: cx - x1, j: cy - y1 };
        }

        // Breaks G2/G3 arc into linear segments for simulation
        function arcToSegments(p1, x2, y2, z2, I, J, isCw, idx, tid, feed) {
            // Center is relative to start point
            const cx = p1.x + I;
            const cz = p1.z + J;
            const r = Math.sqrt(I*I + J*J);
            
            if (r < 0.001) {
                log(`≈Åuk zbyt ma≈Çy (R < 0.001), zamieniam na G1.`, 'WARN');
                return [{start:p1.clone(), end:new THREE.Vector3(x2, y2, z2), type:'G1', lineIdx:idx, feed, toolId:tid}];
            }

            const a1 = Math.atan2(p1.z - cz, p1.x - cx); // Start angle
            let a2 = Math.atan2(z2 - cz, x2 - cx); // End angle
            
            // Angle correction logic for XZ plane (CNC Y is Three.js Z)
            let logicCw = state.invertY ? isCw : !isCw;
            
            if (logicCw) { // CW rotation (G2/G3 logic)
                if (a2 > a1) a2 -= Math.PI * 2;
            } else { // CCW rotation
                if (a2 < a1) a2 += Math.PI * 2;
            }
            
            const deltaAngle = Math.abs(a2 - a1);
            const arcLen = r * deltaAngle;
            let res = Math.max(16, Math.ceil(arcLen * 4)); 
            if (res > 256) res = 256;
            
            const segs = []; 
            const step = (a2 - a1) / res;
            let prev = p1.clone();
            
            for(let k=1; k<=res; k++) {
                const th = a1 + step * k;
                const p = new THREE.Vector3(
                    cx + r * Math.cos(th), 
                    p1.y + (k/res) * (y2 - p1.y), // Interpolate Z (height) linearly
                    cz + r * Math.sin(th)
                );
                segs.push({start:prev.clone(), end:p.clone(), type:'G1', lineIdx:idx, feed, toolId:tid});
                prev = p;
            }
            return segs;
        }

        // --- G-CODE PARSING ---
        function parseLine(line) {
            const params = {};
            const parts = line.match(/([GXYZFIJRZRKQSTHM])([0-9.-]+)/g);
            if(parts) {
                parts.forEach(p => {
                    params[p[0]] = parseFloat(p.slice(1));
                });
            }
            // M codes are usually 3 digits (M03 -> M3), G codes up to 3 digits.
            const codes = line.match(/[GM]\d{1,3}/g) || [];
            codes.forEach(code => {
                 if (code.startsWith('G')) params.G = parseInt(code.slice(1));
                 if (code.startsWith('M')) params.M = parseInt(code.slice(1));
            });
            return params;
        }

        function processCode() {
            log("--- PRZELICZANIE KODU START ---", "INFO");
            const lines = els.input.value.split('\n');
            state.segments = []; pathGroup.clear(); highlightMesh.visible=false; highlightSphere.visible=false;
            
            // Reset bounds for new calculation
            state.bounds.min.set(Infinity, Infinity, Infinity); state.bounds.max.set(-Infinity, -Infinity, -Infinity);

            // Initial state based on global machine state
            let curPos = unmapCoords(toolMesh.position);
            let curMode = state.modalG.move;
            let curFeed = state.curFeed; 
            let curToolId = state.activeToolId;
            let totalTimeMin = 0;
            const usedCodes = new Set();
            
            // Resets state after parse
            updateSimStatus(state.modalG.dist, state.modalG.retract, state.modalG.feed, state.modalG.plane, state.modalG.comp, state.curFeed, state.curRPM);
            
            // Helper function to add segment and update total time
            const addSeg = (start, end, type, lineIdx, feed, toolId) => {
                const dist = start.distanceTo(end);
                
                // Obliczanie finalnego posuwu w mm/min
                let speed_mm_per_min;
                if (type === 'G0') {
                    speed_mm_per_min = CONF.rapidSpeed;
                } else if (state.modalG.feed === 'G95') {
                    // Posuw na obr√≥t (mm/rev) * RPM = mm/min
                    speed_mm_per_min = feed * state.curRPM;
                } else {
                    // Posuw minutowy (mm/min)
                    speed_mm_per_min = feed;
                }

                const speed = speed_mm_per_min;
                const duration = dist / (speed === 0 ? 0.000001 : speed/60); // Time in minutes (mm / mm/min)
                
                state.segments.push({
                    start, end, type, lineIdx, feed: speed_mm_per_min, toolId, // W segmencie przechowujemy F w mm/min
                    dist, duration, startTime: totalTimeMin
                });
                totalTimeMin += duration;
            };

            lines.forEach((line, idx) => {
                let clean = line.replace(/\(.*\)/g, '').split(';')[0].trim().toUpperCase();
                if(!clean) return;
                
                const params = parseLine(clean);

                // Update used codes for legend
                Object.keys(params).forEach(key => {
                    const code = key === 'G' || key === 'M' ? key + params[key] : key;
                    usedCodes.add(code);
                });

                // --- STATE UPDATE (Modal Commands) ---
                if(params.G !== undefined) {
                    const v = params.G;
                    if(v===0) curMode='G0'; else if(v===1) curMode='G1'; else if(v===2) curMode='G2'; else if(v===3) curMode='G3';
                    else if(v===17) state.modalG.plane = 'G17'; else if(v===18) state.modalG.plane = 'G18'; else if(v===19) state.modalG.plane = 'G19';
                    else if(v===40) state.modalG.comp = 'G40'; else if(v===41) state.modalG.comp = 'G41'; else if(v===42) state.modalG.comp = 'G42';
                    else if(v===90) state.modalG.dist = 'G90'; else if(v===91) state.modalG.dist = 'G91';
                    else if(v===94) state.modalG.feed = 'G94'; // Posuw minutowy
                    else if(v===95) state.modalG.feed = 'G95'; // Posuw na obr√≥t
                    else if(v===98) state.modalG.retract = 'G98'; // Wycofanie do Z poczƒÖtkowej
                    else if(v===99) state.modalG.retract = 'G99'; // Wycofanie do R
                    else if(v===80) curMode = 'G0'; // G80 cancels cycle mode, returns to G0 (typically)
                }
                if(params.F !== undefined) curFeed = params.F;
                if(params.S !== undefined) state.curRPM = params.S;
                
                // --- TOOL CHANGE (M6) / TOOL SELECT (T) ---
                const tMatch = clean.match(/T(\d+)/);
                if(tMatch) {
                    let tid = parseInt(tMatch[1]);
                    if(toolsDB.find(t=>t.id==tid)) curToolId = tid;
                }
                if(params.M === 6) { // M6 Tool Change
                    const pSafe = { x: CONF.toolChangePos.x, y: CONF.toolChangePos.y, z: CONF.toolChangePos.z };
                    if(curPos.z < pSafe.z) addSeg(mapCoords(curPos), mapCoords({ ...curPos, z: pSafe.z }), 'G0', idx, CONF.rapidSpeed, curToolId);
                    addSeg(mapCoords({ ...curPos, z: pSafe.z }), mapCoords(pSafe), 'G0', idx, CONF.rapidSpeed, curToolId);
                    curPos = pSafe;
                }


                // --- TARGET CALC ---
                let target = { ...curPos };
                let hasMove = false;
                
                // Apply G91 (Incremental)
                if (state.modalG.dist === 'G91') {
                    if(params.X !== undefined) { target.x += params.X; hasMove=true; }
                    if(params.Y !== undefined) { target.y += params.Y; hasMove=true; }
                    if(params.Z !== undefined) { target.z += params.Z; hasMove=true; }
                } else { // G90 (Absolute)
                    if(params.X !== undefined) { target.x = params.X; hasMove=true; }
                    if(params.Y !== undefined) { target.y = params.Y; hasMove=true; }
                    if(params.Z !== undefined) { target.z = params.Z; hasMove=true; }
                }

                // --- POSUW FINALNY (MM/MIN) ---
                let feed_for_seg = curFeed; 
                
                // Gwintowanie (G84) jest czƒôsto domy≈õlnie w F/rev, nawet w trybie G94, je≈õli F jest skokiem (ma≈Çe F)
                if (params.G === 84 || state.modalG.feed === 'G95') {
                    // W cyklu G84 zak≈Çadamy, ≈ºe F jest skokiem (pitch)
                    feed_for_seg = curFeed * state.curRPM;
                    if (params.G === 84) log(`G84: Posuw przeliczony (F${curFeed} * S${state.curRPM}) na F${feed_for_seg.toFixed(1)} mm/min.`, "INFO");
                }
                // Je≈õli jest G94, feed_for_seg pozostaje curFeed (mm/min).

                // --- CANNED CYCLES (G81/G83/G84) ---
                if (params.G >= 81 && params.G <= 84 && params.G !== 82) {
                    const startZ = curPos.z; // Z przed G0
                    const drillR = params.R || 2; // P≈Çaszczyzna R
                    const finalZ = params.Z || target.z; // G≈Çƒôboko≈õƒá
                    const drillQ = params.Q || 0; // Peck depth (G83)
                    
                    const pStart = mapCoords(curPos);
                    const pR = mapCoords({x:target.x, y:target.y, z:drillR});
                    const pZ = mapCoords({x:target.x, y:target.y, z:finalZ}); 
                    const pFinalRetract = state.modalG.retract === 'G98' ? mapCoords({x:target.x, y:target.y, z:startZ}) : pR;
                    
                    // 1. Rapid do R-plane
                    addSeg(pStart, pR, 'G0', idx, CONF.rapidSpeed, curToolId);
                    
                    if(params.G === 83 && drillQ > 0) { // G83 Peck Cycle
                        let d = drillR;
                        while(d > finalZ) {
                            let n = Math.max(finalZ, d - drillQ);
                            let pIn = mapCoords({x:target.x, y:target.y, z:n});
                            // Plunge
                            addSeg(mapCoords({x:target.x, y:target.y, z:d}), pIn, 'G1', idx, feed_for_seg, curToolId);
                            // Retract
                            addSeg(pIn, pR, 'G0', idx, CONF.rapidSpeed, curToolId);
                            d = n;
                        }
                    } else { // G81 / G84
                        // Plunge to Z
                        addSeg(pR, pZ, 'G1', idx, feed_for_seg, curToolId);
                        // Retract (G84 mo≈ºe wymagaƒá G1 do synchronizacji, ale u≈ºywamy G0 dla uproszczenia wizualizacji ruchu szybkiego wycofania)
                        const retractType = 'G0'; 
                        addSeg(pZ, pFinalRetract, retractType, idx, CONF.rapidSpeed, curToolId);
                    }
                    
                    // Nowa pozycja po cyklu
                    curPos = unmapCoords(pFinalRetract);
                    return; // Skip standard move
                }

                // --- ARCS (G2/G3) ---
                if (hasMove && (curMode==='G2' || curMode==='G3')) {
                    const p1 = mapCoords(curPos); 
                    
                    let I = params.I || 0;
                    let J = params.J || 0;
                    const R = params.R;

                    if(R !== undefined) {
                        const offsets = convertRtoIJ(curPos.x, curPos.y, target.x, target.y, R, curMode==='G2');
                        I = offsets.i;
                        J = offsets.j;
                    }
                    
                    const p2 = mapCoords(target);

                    // Map I, J to XZ plane (World)
                    const I_world = I;
                    const J_world = J * (state.invertY ? 1 : -1);

                    // PASS P2.Y (World Y coordinate of the endpoint)
                    const segs = arcToSegments(p1, p2.x, p2.y, p2.z, I_world, J_world, curMode==='G2', idx, curToolId, feed_for_seg);
                    segs.forEach(s => {
                        const d = s.start.distanceTo(s.end);
                        const speed = s.type === 'G0' ? CONF.rapidSpeed : feed_for_seg;
                        const duration = d / (speed === 0 ? 0.000001 : speed/60);
                        state.segments.push({...s, dist:d, duration:duration, startTime: totalTimeMin});
                        totalTimeMin += duration;
                    });
                    curPos = target; 
                    return;
                }

                // --- LINEAR MOVES (G0/G1) ---
                if(hasMove) {
                    const p1 = mapCoords(curPos); const p2 = mapCoords(target);
                    
                    // Add segment
                    addSeg(p1, p2, curMode, idx, feed_for_seg, curToolId);
                    
                    // Add path visualization to scene
                    const color = curMode==='G0' ? 0xff3333 : 0x00ff00;
                    const mat = curMode==='G0' ? new THREE.LineDashedMaterial({color, dashSize:2, gapSize:2, opacity:0.5, transparent:true}) : new THREE.LineBasicMaterial({color});
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), mat);
                    if(curMode==='G0') line.computeLineDistances();
                    pathGroup.add(line);
                    
                    // Update state
                    curPos = target;
                }
                
                // Always update bounds after potential movement
                updateBounds(mapCoords(curPos));
            });

            state.totalSimTime = totalTimeMin;
            renderLegend(usedCodes);
            const totSec = totalTimeMin * 60;
            els.estTime.innerText = new Date(totSec * 1000).toISOString().substr(11, 8);
            
            // Update G-code extent ranges
            updateRanges();

            resetSim();
            log(`Przeliczono ${state.segments.length} segment√≥w w ${totalTimeMin.toFixed(2)} min.`, "OK");
            saveData();
        }
        
        // --- Deformable Stock Logic ---
        function deformStockSegment(p1, p2, toolId) {
            if (!state.stockMesh) return;
            const t = toolsDB.find(x=>x.id==toolId) || toolsDB[0];
            const r = t.dia / 2; const rSq = r*r;
            
            const geo = state.stockMesh.geometry; 
            const posAttr = geo.attributes.position; 
            const colAttr = geo.attributes.color;
            
            const w = parseFloat(els.stockW.value); 
            const d = parseFloat(els.stockD.value); 
            const stockH = parseFloat(els.stockH.value);
            
            const segs = CONF.millRes;
            const stepX = w / segs; 
            const stepZ = d / segs;
            
            const p1x = p1.x; const p1z = p1.z;
            const p2x = p2.x; const p2z = p2.z;

            // Define bounding box for iteration (optimization)
            const minX = Math.min(p1x, p2x) - r - stepX; 
            const maxX = Math.max(p1x, p2x) + r + stepX;
            const minZ = Math.min(p1z, p2z) - r - stepZ;
            const maxZ = Math.max(p1z, p2z) + r + stepZ;

            const iMinX = Math.max(0, Math.floor((minX + w/2) / stepX));
            const iMaxX = Math.min(segs, Math.ceil((maxX + w/2) / stepX));
            const iMinZ = Math.max(0, Math.floor((minZ + d/2) / stepZ));
            const iMaxZ = Math.min(segs, Math.ceil((maxZ + d/2) / stepZ));

            const tipH = Math.min(p1.y, p2.y); // Lowest tool Y during this segment
            
            const l2 = (p1x-p2x)**2 + (p1z-p2z)**2; // Segment length squared in XZ
            const isBall = t.type==='BALL'; const isDrill = t.type==='DRILL' || t.type==='TAP';

            // Iterate over relevant grid points
            for(let iz=iMinZ; iz<=iMaxZ; iz++) {
                for(let ix=iMinX; ix<=iMaxX; ix++) {
                    const gridIdx = (segs - iz) * (segs + 1) + ix;
                    if (gridIdx < 0 || gridIdx >= state.gridMap.length) continue;
                    
                    const vertices = state.gridMap[gridIdx];
                    if (!vertices || vertices.length === 0) continue;

                    const wx = (ix * stepX) - w/2;
                    const wz = (iz * stepZ) - d/2;

                    // Calculate shortest distance from grid point (wx, wz) to segment (p1xz, p2xz)
                    let distSq;
                    if(l2===0) distSq = (wx-p1x)**2 + (wz-p1z)**2;
                    else {
                        let t = ((wx-p1x)*(p2x-p1x) + (wz-p1z)*(p2z-p1z)) / l2; t = Math.max(0, Math.min(1, t));
                        distSq = (wx-(p1x+t*(p2x-p1x)))**2 + (wz-(p1z+t*(p2z-p1z)))**2;
                    }

                    if(distSq < rSq) {
                        const firstV = vertices[0];
                        const currentWorldY = posAttr.getY(firstV) - stockH/2;

                        let targetWorldY = tipH;
                        if(isBall) {
                            targetWorldY = tipH + (r - Math.sqrt(Math.max(0, rSq - distSq)));
                        } else if(isDrill && distSq < 0.01) { // Only affects center for drill
                             targetWorldY = tipH; // Drill tip point
                        }

                        if(currentWorldY > targetWorldY) {
                            const newLocalY = targetWorldY + stockH/2;
                            // Color based on depth (Heatmap effect)
                            const depthRatio = (-targetWorldY) / stockH; // 0 (top) to 1 (bottom)
                            const c = new THREE.Color().setHSL(0.6 - depthRatio * 0.6, 1.0, 0.5); // Blue to Red
                            
                            for(let k=0; k<vertices.length; k++) {
                                const vIdx = vertices[k];
                                posAttr.setY(vIdx, newLocalY);
                                colAttr.setXYZ(vIdx, c.r, c.g, c.b);
                            }
                        }
                    }
                }
            }
            posAttr.needsUpdate=true; colAttr.needsUpdate=true; 
        }

        // --- SIMULATION LOOP ---
        function animate() {
            requestAnimationFrame(animate); 
            controls.update(); 
            chipSystem.update();
            frameCount++;

            // Dt is time in seconds since last frame
            const dt = clock.getDelta(); 
            
            // Update DRO only when not playing, or on mouse move in MDI
            if (state.mode === 'MDI') {
                updateDRO(toolMesh.position);
            }
            
            // Optimization: Recompute normals occasionally
            if (state.stockMesh && (state.isPlaying || frameCount % 60 === 0)) {
                state.stockMesh.geometry.computeVertexNormals();
            }

            if (!state.isPlaying || state.mode === 'MDI') {
                renderer.render(scene, camera);
                return;
            }
            
            // Calculate time to advance in simulation minutes
            // Simulation time = Real time (seconds) * Speed multiplier / 60 seconds/minute
            let timeToAdvance = (dt / 60) * state.speed; 

            // Sub-step simulation loop
            while (timeToAdvance > 0 && state.isPlaying) {
                if (state.currentSegmentIdx >= state.segments.length) {
                    state.isPlaying = false;
                    state.currentSegmentIdx = state.segments.length - 1; 
                    state.progress = 1;
                    updatePlayUI();
                    log("Program zako≈Ñczony. M30.", "OK");
                    break;
                }

                const seg = state.segments[state.currentSegmentIdx];
                const segDuration = seg.duration || 0.000001; 
                const remainingInSeg = (1 - state.progress) * segDuration;

                if (timeToAdvance >= remainingInSeg) {
                    // Segment completes this step
                    const endPos = seg.end;
                    const currentPos = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress);
                    
                    if(seg.type === 'G1') {
                        deformStockSegment(currentPos, endPos, seg.toolId);
                        chipSystem.emit(endPos, 1.0);
                    }

                    if(seg.toolId !== state.activeToolId) updateToolMesh(seg.toolId);
                    toolMesh.position.copy(endPos);

                    timeToAdvance -= remainingInSeg;
                    state.progress = 0;
                    state.currentSegmentIdx++;
                    state.simulatedHeadIdx = state.currentSegmentIdx;

                } else {
                    // Segment moves partially
                    const fractionToMove = timeToAdvance / segDuration;
                    state.progress += fractionToMove;
                    
                    const pOld = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress - fractionToMove);
                    const pNew = new THREE.Vector3().lerpVectors(seg.start, seg.end, state.progress);
                    
                    if(seg.type === 'G1') {
                        deformStockSegment(pOld, pNew, seg.toolId);
                        chipSystem.emit(pNew, 0.2);
                    }
                    
                    if(seg.toolId !== state.activeToolId) updateToolMesh(seg.toolId);
                    toolMesh.position.copy(pNew);
                    
                    // Collision check for G0 (Rapid)
                    if (seg.type === 'G0') {
                        const matH = getMaterialHeightAt(pNew.x, pNew.z);
                        if (pNew.y < (matH - 0.5)) {
                            state.isPlaying = false;
                            els.collisionMsg.innerText = "G0 (RAPID) W MATERIALE! Zatrzymanie awaryjne.";
                            els.collisionAlert.classList.remove('hidden');
                            updatePlayUI();
                            log(`KOLIZJA: G0 w materiale na linii ${seg.lineIdx+1}. Zatrzymano symulacjƒô.`, "ERR");
                            timeToAdvance = 0; 
                            break;
                        }
                    }

                    timeToAdvance = 0;
                }
            }

            // UI Update
            if(state.segments.length > 0 && state.currentSegmentIdx < state.segments.length) {
                const curSeg = state.segments[state.currentSegmentIdx];
                const currentRunTime = curSeg.startTime + (curSeg.duration * state.progress);
                const ratio = currentRunTime / (state.totalSimTime || 1);
                
                els.percent.innerText = `${Math.floor(Math.min(100, ratio*100))}%`;
                els.lineIdx.innerText = `N: ${curSeg.lineIdx > -1 ? curSeg.lineIdx + 1 : 'MDI'}`;
                els.slider.value = ratio * 1000;
                updateDRO(toolMesh.position);
                highlightSelection(curSeg, state.progress);
            }

            renderer.render(scene, camera);
        }

        // --- UI/STATUS UPDATES ---
        function updateDRO(pos) {
            const cncPos = unmapCoords(pos);
            state.curPos = pos.clone(); // Update machine state position in World
            
            els.posX.innerText = cncPos.x.toFixed(3); 
            els.posY.innerText = cncPos.y.toFixed(3); 
            els.posZ.innerText = cncPos.z.toFixed(3);

            // Shank Collision Detection
            const t = toolsDB.find(x=>x.id==state.activeToolId) || toolsDB[0];
            const fluteLength = t.len;
            const matH = getMaterialHeightAt(pos.x, pos.z);

            // Check if tool holder (shank) is in material
            if (pos.y < (matH - fluteLength - 0.5)) { 
                toolShank.material.color.setHex(0xff0000); 
                els.collisionMsg.innerText = "OPRAWKA W MATERIALE! Zatrzymanie awaryjne.";
                els.collisionAlert.classList.remove('hidden'); 
            } else { 
                toolShank.material.color.setHex(0xaaaaaa); 
                if (els.collisionMsg.innerText.includes("OPRAWKA")) els.collisionAlert.classList.add('hidden'); 
            }
        }
        
        function updateSimStatus(dist, retract, feedMode, plane, comp, feed, rpm) {
            // Generuje dynamiczny tekst modalny bez prefix√≥w
            els.statusMode.innerText = `${dist} ABSOLUTNY`;
            els.statusRetract.innerText = `${retract} Wycofanie: ${retract === 'G98' ? 'START' : 'R-P≈ÅASZCZ.'}`;
            els.statusFeedMode.innerText = `${feedMode} Posuw: ${feedMode === 'G94' ? 'MINUTOWY' : 'NA OBR√ìT'}`;
            els.statusPlane.innerText = `${plane} P≈Çaszczyzna: XY`;
            els.statusComp.innerText = `${comp} Kompensacja: OFF`;
            els.statusFeed.innerText = `F ${feed}`;
            els.statusRpm.innerText = `S ${rpm}`;
        }
        
        function updateRanges() {
            if (state.bounds.min.x === Infinity) {
                // If no movement occurred, display reset values
                els.rangeX.innerText = `-`;
                els.rangeY.innerText = `-`;
                els.rangeZ.innerText = `-`;
                return;
            }
            
            // X and Z are World coordinates for bounds. Z = CNC Y
            const minX = state.bounds.min.x.toFixed(2);
            const maxX = state.bounds.max.x.toFixed(2);
            // Z World = CNC Y. Invert for proper min/max if needed.
            const minY = (state.bounds.min.z * (state.invertY ? 1 : -1)).toFixed(2);
            const maxY = (state.bounds.max.z * (state.invertY ? 1 : -1)).toFixed(2);
            // World Y = CNC Z (Depth). World Y=0 is max Z (top) / min depth.
            const minZ = (-state.bounds.max.y).toFixed(2); 
            const maxZ = (-state.bounds.min.y).toFixed(2); 
            
            els.rangeX.innerText = `${minX}/${maxX}`;
            els.rangeY.innerText = `${minY}/${maxY}`;
            els.rangeZ.innerText = `${minZ}/${maxZ}`;
        }

        // --- RESET AND SIMULATION CONTROL ---
        function resetSim() {
            state.isPlaying = false; state.currentSegmentIdx = 0; state.progress = 0; 
            els.slider.value = 0; els.percent.innerText = "0%"; updatePlayUI();
            
            if(state.segments.length>0) { 
                toolMesh.position.copy(state.segments[0].start); 
                if(state.segments[0].toolId !== state.activeToolId) updateToolMesh(state.segments[0].toolId); 
            } else {
                 toolMesh.position.set(0, CONF.toolChangePos.z, 0); // Default home position
            }
            
            // Reset modal G-codes to default safe values
            state.modalG.move = 'G0'; state.modalG.dist = 'G90';
            state.modalG.feed = 'G94'; state.modalG.retract = 'G98';

            updateDRO(toolMesh.position);
            restoreStock(); 
            highlightMesh.visible=false; highlightSphere.visible=false; els.collisionAlert.classList.add('hidden');
        }
        
        function restoreStock() {
            if(!state.stockMesh) return;
            const geo = state.stockMesh.geometry;
            const pos = geo.attributes.position; 
            const col = geo.attributes.color; 
            const h = parseFloat(els.stockH.value);
            const topColor = new THREE.Color(CONF.colorStockTop);
            const map = state.gridMap;
            if(!map) return;

            map.forEach(indices => {
                indices.forEach(idx => {
                    pos.setY(idx, h/2); 
                    col.setXYZ(idx, topColor.r, topColor.g, topColor.b);
                });
            });
            pos.needsUpdate=true; col.needsUpdate=true; geo.computeVertexNormals();
            state.simulatedHeadIdx = 0;
            updateRanges();
        }

        function simulateToState(idx) {
            if(idx < state.simulatedHeadIdx) restoreStock();
            for(let i=state.simulatedHeadIdx; i<idx; i++) { 
                const s = state.segments[i]; 
                if(s.type==='G1') deformStockSegment(s.start, s.end, s.toolId); 
            }
            state.simulatedHeadIdx = idx;
        }

        // --- PLAYBACK UI EVENTS ---
        function onSliderScrub(e) {
            if (state.mode !== 'AUTO') return;
            state.isPlaying=false; updatePlayUI(); 
            const ratio = e.target.value/1000;
            const targetTime = ratio * state.totalSimTime;
            
            let foundIdx = 0;
            for(let i=0; i<state.segments.length; i++) {
                const s = state.segments[i];
                if (targetTime >= s.startTime && targetTime <= (s.startTime + s.duration)) { foundIdx = i; break; }
                if (targetTime > s.startTime + s.duration) foundIdx = i; 
            }
            
            const s = state.segments[foundIdx];
            if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            state.currentSegmentIdx = foundIdx;
            const segTime = targetTime - s.startTime;
            state.progress = segTime / (s.duration || 1); if(state.progress > 1) state.progress = 1;
            
            const pos = new THREE.Vector3().lerpVectors(s.start, s.end, state.progress); 
            
            simulateToState(foundIdx); 
            if(s.type==='G1') deformStockSegment(s.start, pos, s.toolId);
            
            toolMesh.position.copy(pos); 
            updateDRO(pos);
            els.percent.innerText = `${Math.floor(ratio*100)}%`; 
            els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            highlightSelection(s, state.progress);
        }
        
        function selectSeg(i, scrollEditor=true) {
            if (state.mode !== 'AUTO') return;
            if(i<0 || i>=state.segments.length) return; 
            
            state.currentSegmentIdx=i; state.progress=0; state.isPlaying=false; updatePlayUI();
            
            const s = state.segments[i]; 
            if(s.toolId!==state.activeToolId) updateToolMesh(s.toolId);
            
            toolMesh.position.copy(s.start); 
            updateDRO(s.start);
            highlightSelection(s, 0); 
            if(scrollEditor) highlightLineInEditor(s.lineIdx);
            
            const ratio = s.startTime / (state.totalSimTime || 1);
            els.percent.innerText = `${Math.floor(ratio*100)}%`; 
            els.slider.value=ratio*1000; 
            els.lineIdx.innerText = `N: ${s.lineIdx+1}`;
            
            simulateToState(i);
        }
        
        function highlightSelection(s, progress) {
            // Update line
            const a = highlightMesh.geometry.attributes.position; 
            a.setXYZ(0, s.start.x, s.start.y, s.start.z); 
            a.setXYZ(1, s.end.x, s.end.y, s.end.z);
            a.needsUpdate=true; 
            highlightMesh.visible=true; 
            
            // Update sphere (Current Tool Position)
            const pos = new THREE.Vector3().lerpVectors(s.start, s.end, progress);
            highlightSphere.position.copy(pos); 
            highlightSphere.visible=true;
            
            // Highlight editor line
            highlightLineInEditor(s.lineIdx);
        }
        
        function highlightLineInEditor(l) { 
            const line = els.input.value.split('\n')[l];
            if (!line) return;
            const charCount = els.input.value.substring(0, els.input.selectionStart).split('\n').slice(0, l).join('\n').length + l;
            els.input.focus();
            els.input.setSelectionRange(charCount, charCount + line.length);
            els.input.scrollTop = (l*20) - (els.input.clientHeight/2) + 20; 
        }
        
        function updatePlayUI() { 
            if(state.isPlaying) { 
                els.iconPlay.classList.add('hidden'); els.iconPause.classList.remove('hidden'); 
            } else { 
                els.iconPlay.classList.remove('hidden'); els.iconPause.classList.add('hidden'); 
            } 
        }
        
        function on3DClick(e) {
            if (state.mode !== 'AUTO') return;
            const r=renderer.domElement.getBoundingClientRect(); 
            mouse.x=((e.clientX-r.left)/r.width)*2-1; 
            mouse.y=-((e.clientY-r.top)/r.height)*2+1;
            raycaster.setFromCamera(mouse, camera);
            
            let min=Infinity, idx=-1;
            for(let i=0; i<state.segments.length; i++) { 
                const d = raycaster.ray.distanceSqToSegment(state.segments[i].start, state.segments[i].end); 
                if(d<min) { min=d; idx=i; } 
            }
            if(idx!==-1 && min<5) selectSeg(idx);
        }
        
        function onEditorClick() {
            if (state.mode !== 'AUTO') return;
            const l = els.input.value.substring(0, els.input.selectionStart).split('\n').length-1;
            // Find the first segment starting on this line
            const i = state.segments.findIndex(s => s.lineIdx === l); 
            if(i!==-1) selectSeg(i, false);
        }

        // --- G-Code Legend UI ---
        function renderLegend(set) {
            const el = els.gcodeLegend; el.innerHTML='';
            
            for(let [k,v] of Object.entries(G_CATS)) {
                const d = document.createElement('div'); d.className='legend-cat'; d.innerText=k; el.appendChild(d);
                v.forEach(c => {
                    const row = document.createElement('div'); row.className='gcode-row '+(set.has(c)?'active-code':'');
                    row.innerHTML=`<span class="gcode-key">${c}</span><span>${G_DESC[c]||'Funkcja'}</span>`;
                    el.appendChild(row);
                });
            }
            
            const allKnown = new Set(Object.values(G_CATS).flat());
            const unknownActive = Array.from(set).filter(c => !allKnown.has(c));
            
            if(unknownActive.length > 0) {
                const header = document.createElement('div');
                header.className = 'legend-cat';
                header.innerText = "INNE / NIEROZPOZNANE";
                header.style.color = '#fbbf24'; 
                el.appendChild(header);
                
                unknownActive.sort().forEach(c => {
                    const div = document.createElement('div');
                    div.className = 'gcode-row active-code';
                    div.innerHTML = `<span class="gcode-key">${c}</span> <span>${G_DESC[c] || 'Nierozpoznany'}</span>`;
                    el.appendChild(div);
                });
            }
        }
        
        // --- MDI COMMAND EXECUTION ---
        function executeMDICommand(command) {
            const params = parseLine(command);
            
            // 1. Handle Tool Change (T, M6)
            const tMatch = command.match(/T(\d+)/);
            if(tMatch) {
                let tid = parseInt(tMatch[1]);
                const newTool = toolsDB.find(t => t.id === tid);
                if (newTool) {
                    state.activeToolId = tid;
                    updateToolMesh(tid);
                    log(`Wybrano narzƒôdzie T${tid}.`, "OK");
                } else {
                    log(`Narzƒôdzie T${tid} nie jest zdefiniowane.`, "WARN");
                }
            }
            if (params.M === 6) {
                log("Wykonano M06: Wymiana narzƒôdzia.", "OK");
            }
            
            // 2. Handle Modal Changes
            if(params.G !== undefined) {
                const v = params.G;
                if(v === 0) state.modalG.move = 'G0'; 
                else if(v === 1) state.modalG.move = 'G1'; 
                else if(v === 90) state.modalG.dist = 'G90';
                else if(v === 91) state.modalG.dist = 'G91';
                else if(v === 94) state.modalG.feed = 'G94';
                else if(v === 95) state.modalG.feed = 'G95';
                else if(v === 98) state.modalG.retract = 'G98';
                else if(v === 99) state.modalG.retract = 'G99';
                else if(v === 54) log("Ustawiono G54 (WCS1).", "OK");
            }
            if(params.F !== undefined) state.curFeed = params.F;
            if(params.S !== undefined) state.curRPM = params.S;

            // 3. Handle Movement
            const moveType = state.modalG.move;
            const isIncremental = state.modalG.dist === 'G91';
            
            let target = unmapCoords(toolMesh.position);
            let hasMove = false;
            
            if(params.X !== undefined) { target.x = isIncremental ? target.x + params.X : params.X; hasMove=true; }
            if(params.Y !== undefined) { target.y = isIncremental ? target.y + params.Y : params.Y; hasMove=true; }
            if(params.Z !== undefined) { target.z = isIncremental ? target.z + params.Z : params.Z; hasMove=true; }

            if(hasMove) {
                const p1 = toolMesh.position.clone();
                const p2 = mapCoords(target);

                if (moveType === 'G1') {
                    // W MDI u≈ºywamy sta≈Çego, widocznego posuwu
                    deformStockSegment(p1, p2, state.activeToolId);
                    log(`Wykonano G1 do X${target.x.toFixed(3)} Y${target.y.toFixed(3)} Z${target.z.toFixed(3)}.`, "OK");
                } else { // G0
                    // Check for G0 collision
                    const startH = getMaterialHeightAt(p1.x, p1.z);
                    const endH = getMaterialHeightAt(p2.x, p2.z);
                    if (p1.y < (startH - 0.5) || p2.y < (endH - 0.5)) {
                        log("KOLIZJA: Ruch G0 z/przez materia≈Ç. Zatrzymano.", "ERR");
                        els.collisionMsg.innerText = "G0 MDI W MATERIALE!";
                        els.collisionAlert.classList.remove('hidden');
                        return;
                    }
                    log(`Wykonano G0 do X${target.x.toFixed(3)} Y${target.y.toFixed(3)} Z${target.z.toFixed(3)}.`, "OK");
                }
                
                toolMesh.position.copy(p2);
            }
            
            // Update UI/DRO status after execution
            updateDRO(toolMesh.position);
            updateSimStatus(state.modalG.dist, state.modalG.retract, state.modalG.feed, state.modalG.plane, state.modalG.comp, state.curFeed, state.curRPM);
            if(state.stockMesh) state.stockMesh.geometry.computeVertexNormals();
        }

        // --- EXPORT FUNCTIONS ---
        function exportToTXT() {
            if (!state.stockMesh) { log("Brak modelu materia≈Çu do eksportu.", "WARN"); return; }
            let output = "# Eksport Chmury Punkt√≥w (Powierzchnia obrobiona)\n# X Y Z (mm)\n";
            const pos = state.stockMesh.geometry.attributes.position;
            const { w, d, h, segs, stepX, stepZ } = state.stockDims;
            
            state.gridMap.forEach((indices, gridIdx) => {
                if(indices.length > 0) {
                    const i = indices[0]; 
                    const ly = pos.getY(i);
                    const worldY = ly - h/2; // World Y (Z-axis)
                    
                    // Convert grid index back to World X/Z (CNC X/Y)
                    const iz = segs - Math.floor(gridIdx / (segs + 1));
                    const ix = gridIdx % (segs + 1);
                    
                    const wx = (ix * stepX) - w/2; // World X (CNC X)
                    const wz = (iz * stepZ) - d/2; // World Z (CNC -Y or Y)
                    
                    const cncY = wz * (state.invertY ? 1 : -1);
                    const cncZ = worldY;

                    output += `${wx.toFixed(3)} ${cncY.toFixed(3)} ${cncZ.toFixed(3)}\n`;
                }
            });
            const blob = new Blob([output], { type: 'text/plain' });
            const l = document.createElement('a'); l.href = URL.createObjectURL(blob); l.download = 'cnc_cloud.txt'; l.click();
            log("Wyeksportowano chmurƒô punkt√≥w do cnc_cloud.txt", "OK");
        }
        
        // --- BUTTON HANDLERS ---
        els.btnPlay.addEventListener('click', () => { 
            if (state.mode === 'MDI') return;
            if(state.segments.length>0) { 
                if(state.currentSegmentIdx>=state.segments.length-1 && state.progress>=0.99) { 
                    state.currentSegmentIdx=0; state.progress=0; restoreStock();
                } 
                state.isPlaying=!state.isPlaying; updatePlayUI(); 
            } else {
                log("Brak segment√≥w do odtworzenia. Przelicz kod.", "WARN");
            }
        });
        els.btnReset.addEventListener('click', resetSim); 
        els.btnRender.addEventListener('click', processCode);
        els.btnUpdateStock.addEventListener('click', () => { updateEnvironment(); resetSim(); });
        els.chkInvertY.addEventListener('change', (e) => { state.invertY = e.target.checked; processCode(); });
        els.chkComp.addEventListener('change', (e) => { state.useComp = e.target.checked; processCode(); });
        
        els.modeAutoBtn.addEventListener('click', () => setUIMode('AUTO'));
        els.modeMdiBtn.addEventListener('click', () => setUIMode('MDI'));
        
        el('file-upload').addEventListener('change', (e) => { 
            const f=e.target.files[0]; 
            if(!f)return; 
            const r=new FileReader(); 
            r.onload=(ev)=>{
                els.input.value=ev.target.result; 
                updateLineNumbers(); 
                processCode(); 
                saveData();
                log(`Za≈Çadowano plik: ${f.name}`, "OK");
            }; 
            r.readAsText(f); 
        });
        el('cam-iso').addEventListener('click', () => { camera.position.set(120, 150, 200); controls.target.set(0,0,0); controls.update(); });
        el('cam-top').addEventListener('click', () => { camera.position.set(0, 250, 0); controls.target.set(0,0,0); controls.update(); });
        
        el('btn-save-local').addEventListener('click', () => { saveData(); log("Zapisano stan do pamiƒôci przeglƒÖdarki.", "INFO"); });
        els.btnExportTXT.addEventListener('click', exportToTXT);
        
        els.btnExportSTL.addEventListener('click', () => { 
            if (!state.stockMesh) { log("Brak modelu materia≈Çu do eksportu STL.", "WARN"); return; }
            const e = new STLExporter(); 
            state.stockMesh.geometry.computeVertexNormals();
            const r = e.parse(state.stockMesh); 
            const b = new Blob([r], {type:'text/plain'}); 
            const l = document.createElement('a'); 
            l.href = URL.createObjectURL(b); 
            l.download = 'cnc_solid.stl'; 
            l.click(); 
            log("Wyeksportowano model 3D (STL).", "OK");
        });

        // Sample G-Code for the editor
        const sampleMill = `(MASTER SHOWCASE V3.4)
(Stock: 100x100x20 | Baza: Srodek X0 Y0)

(USTAWIENIA: G94-Posuw Minutowy / G98-Wycofanie do Z startowej)
G90 G17 G54 G94 G98
G0 Z50

(--- OP 1: PLANOWANIE POWIERZCHNI [T1 GLOWICA] ---)
(Zbieramy 1mm z gory aby wyrownac material)
T1 M6
S2000 M3
G0 X-60 Y0
G0 Z5
G1 Z-1 F800
G1 X60
G0 Z50

(--- OP 2: KIESZEN Z WYSPA [T2 FREZ 10] ---)
(Frezowanie ksztaltu wybierajacego material)
T2 M6
S3000 M3
G0 X-35 Y-35
G0 Z5
G1 Z-4 F1000

(Obwiednia zewnetrzna)
G1 X35
G1 Y35
G1 X-35
G1 Y-35

(Wyspa srodkowa - pozostawienie materialu)
G0 Z5
G0 X-20 Y-20
G1 Z-4 F1000
G1 X20
G1 Y20
G1 X-20
G1 Y-20
G0 Z50

(--- OP 3: OKRAG WEWNATRZ [T3 KULA 6] ---)
(Frezowanie okregu G3 wewnatrz wyspy)
T3 M6
S4500 M3
G0 X15 Y0
G0 Z2
G1 Z-2 F1200
(Polkole 1 CCW)
G3 X-15 Y0 I-15 J0
(Polkole 2 CCW)
G3 X15 Y0 I15 J0
G0 Z50

(--- OP 4: WIERCENIE OTWOROW [T4 WIERTLO] ---)
(Cykl G83 - z wycofaniem wiora)
T4 M6
S1500 M3
G0 Z20
(Otwor 1)
G0 X40 Y40
G83 X40 Y40 Z-15 R2 Q4 F300
(Otwor 2)
G83 X-40 Y40 Z-15 R2 Q4
(Otwor 3)
G83 X-40 Y-40 Z-15 R2 Q4
(Otwor 4)
G83 X40 Y-40 Z-15 R2 Q4
G80
G0 Z50

(--- OP 5: GWINTOWANIE [T5 GWINTOWNIK] ---)
(Cykl G84 - Posuw jako SKOK F1.5 w G94 -> konwersja na F_min)
T5 M6
S400 M3
G94 (Posuw minutowy)
G0 Z20
G0 X40 Y40
G84 X40 Y40 Z-12 R5 F1.5
G84 X-40 Y40 Z-12 R5
G84 X-40 Y-40 Z-12 R5
G84 X40 Y-40 Z-12 R5
G80
G0 Z50

(Koniec)
G0 X0 Y0
M30`;
        init();
    </script>
</body>
</html>
